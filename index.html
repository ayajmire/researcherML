<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ResearcherML - Machine Learning Research Platform</title>
    <link rel="stylesheet" href="/css/styles.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
</head>

<body>
    <div class="app-layout">
        <!-- Left Sidebar Navigation -->
        <aside class="sidebar-nav" id="workflowNav" role="navigation" aria-label="Main navigation">
            <div class="sidebar-header">
                <h2>ResearcherML</h2>
            </div>
            <nav class="sidebar-menu" id="sidebarMenu">
                <!-- Navigation items will be dynamically rendered based on model type -->
            </nav>
        </aside>

        <!-- Main Content Area -->
        <div class="main-content">
            <div class="container">
                <div class="header">
                    <h1>ResearcherML</h1>
                    <p>Machine Learning Research Platform</p>
                </div>

                <div class="model-selection" id="modelSelection">
                    <h3>Select Model Type</h3>
                    <div class="model-options">
                        <div class="model-option" data-type="ehr" onclick="selectModelType('ehr')">
                            <h4>EHR / Tabular</h4>
                            <p>Electronic Health Records & Tabular Data</p>
                        </div>
                    </div>

                    <h3 style="margin-top: 30px;">Select Model Action</h3>
                    <div class="model-options">
                        <div class="model-option" data-action="classification"
                            onclick="selectModelAction('classification')">
                            <h4>Classification</h4>
                            <p>Predict categories or classes</p>
                        </div>
                        <div class="model-option" data-action="regression" onclick="selectModelAction('regression')">
                            <h4>Regression</h4>
                            <p>Predict continuous values</p>
                        </div>
                    </div>
                </div>

                <div class="upload-section" id="uploadSection">
                    <div class="upload-box" id="uploadBox">
                        <div class="upload-icon"></div>
                        <div class="upload-text">Drop your file here</div>
                        <div class="upload-subtext" id="uploadSubtext">or click to browse (single file only)</div>
                        <button class="browse-btn" onclick="window.openFilePicker()">
                            Browse File
                        </button>
                        <input type="file" id="fileInput" class="file-input" accept=".csv,.tsv,.txt,.json">
                    </div>

                    <div class="file-list" id="fileList"></div>

                    <div class="supported-formats">
                        <h4>Supported Formats:</h4>
                        <div class="formats-list">
                            <span class="format-tag">CSV/TSV</span>
                            <span class="format-tag">TXT/JSON</span>
                        </div>
                    </div>
                </div>

                <button class="upload-btn" id="uploadBtn" onclick="uploadFiles()" disabled
                    style="display: none; visibility: hidden;">
                    Upload & Process File
                </button>

                <button class="upload-btn" id="newUploadBtn" onclick="handleNewUploadClick(event)"
                    style="display: none; visibility: hidden; background: #0071e3; margin-top: 15px;">
                    Upload New File
                </button>

                <div class="loading" id="loading">
                    <div class="spinner"></div>
                    <div>Processing your file...</div>
                </div>

                <div class="result" id="result"></div>

                <div class="data-viewer" id="dataViewer">
                    <h3>Dataset Viewer</h3>
                    <div id="viewerContent"></div>
                </div>

                <div class="data-viewer" id="cleaningPage" style="display: none;">
                    <h3>Data Cleaning & Preprocessing</h3>
                    <div id="cleaningContent"></div>
                </div>

                <div class="data-viewer" id="featureEngineeringPage" style="display: none;">
                    <h3>Feature Engineering</h3>
                    <div id="featureEngineeringContent"></div>
                </div>

                <div class="data-viewer" id="visualizationPage" style="display: none;">
                    <h3>Data Visualization</h3>
                    <div id="visualizationContent"></div>
                </div>

                <div class="data-viewer" id="modelTrainingPage" style="display: none;">
                    <h3>Model Training Preparation</h3>
                    <div id="modelTrainingContent"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables moved to frontend/js/config.js

        // File upload handling, drag & drop, and upload functions moved to js/upload.js and js/utils.js modules
        // Event listeners are initialized in upload.js module
        /* Upload functions now in modules:
        async function uploadFiles() {
            if (selectedFiles.length === 0 || !selectedModelType || !selectedModelAction) return;

            // Check if there's existing data and prompt user to save it
            if (uploadedData || (allData && allData.length > 0)) {
                const shouldSave = confirm(
                    'You have existing data loaded. Would you like to save the current dataset to your device before uploading a new file?\n\n' +
                    'Click "OK" to download the current dataset as JSON, or "Cancel" to proceed without saving.'
                );

                if (shouldSave) {
                    // Save current dataset to JSON file
                    saveCurrentDataset();
                }

                // Clear all cached data and reset variables
                clearAllCachedData();
            }

            const loading = document.getElementById('loading');
            const result = document.getElementById('result');
            const uploadBtn = document.getElementById('uploadBtn');

            // Set upload in progress flag
            window.isUploadInProgress = true;

            // Disable upload button to prevent double uploads
            uploadBtn.disabled = true;
            uploadBtn.innerHTML = 'Processing...';

            loading.style.display = 'block';
            result.style.display = 'none';

            try {
                const formData = new FormData();
                selectedFiles.forEach(file => {
                    formData.append('files', file);
                });
                formData.append('model_type', selectedModelType);
                formData.append('model_action', selectedModelAction);

                const response = await fetch('http://localhost:8000/api/upload', {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();

                loading.style.display = 'none';

                if (response.ok) {
                    result.className = 'result success';
                    let warningHtml = '';
                    if (data.warning) {
                        warningHtml = `<div style="color: #d69e2e; margin-top: 10px; padding: 8px; background: #fefcbf; border: 1px solid #f6e05e; border-radius: 4px; font-size: 0.9rem;">${data.warning}</div>`;
                    }
                    result.innerHTML = `
                        <strong>Success!</strong><br>
                        ${data.message}<br>
                        <small>Detected type: ${data.detected_type} | Selected model: ${data.selected_model_type} | Action: ${data.selected_model_action}</small>
                        ${warningHtml}
                    `;
                    result.style.display = 'block';

                    // Store uploaded data and show viewer
                    uploadedData = data;

                    // Ensure dataModified is false for new upload
                    dataModified = false;
                    localStorage.removeItem('dataModified');

                    // Persist uploaded data to localStorage so it survives page refreshes
                    localStorage.setItem('uploadedData', JSON.stringify(data));

                    showDataViewer(data);

                    // Clear the form but don't reset upload button yet
                    selectedFiles = [];
                    selectedModelType = null;
                    selectedModelAction = null;
                    updateFileList();
                    document.querySelectorAll('.model-option').forEach(option => {
                        option.classList.remove('selected');
                    });

                    // Show new upload button and hide original
                    document.getElementById('newUploadBtn').style.display = 'block';
                    uploadBtn.style.display = 'none';

                    // Clear file input
                    document.getElementById('fileInput').value = '';

                    // Reset upload flag
                    window.isUploadInProgress = false;

                } else {
                    throw new Error(data.detail || 'Upload failed');
                }
            } catch (error) {
                // Reset upload flag
                window.isUploadInProgress = false;

                loading.style.display = 'none';
                result.className = 'result error';
                result.innerHTML = `<strong>Error:</strong> ${error.message}`;
                result.style.display = 'block';

                // Re-enable upload button on error
                uploadBtn.disabled = false;
                uploadBtn.innerHTML = 'Upload & Process File';
                uploadBtn.style.background = 'linear-gradient(135deg, #10B981 0%, #34D399 100%)';
            }
        }

        function handleNewUploadClick(event) {
            // First, quickly show upload section so file input is accessible
            const uploadSection = document.getElementById('uploadSection');
            const modelSelection = document.getElementById('modelSelection');
            if (uploadSection) {
                uploadSection.style.display = 'block';
                uploadSection.style.visibility = 'visible';
            }
            if (modelSelection) {
                modelSelection.style.display = 'block';
                modelSelection.style.visibility = 'visible';
            }

            // IMPORTANT: Open file picker IMMEDIATELY while still in user interaction chain
            // This must happen before any async operations or the browser will block it
            const fileInput = document.getElementById('fileInput');
            if (fileInput) {
                fileInput.value = '';
                // Don't change display/visibility - keep it hidden, just trigger click
                fileInput.disabled = false;
                fileInput.click();
                console.log('File picker opened from user click');
            } else {
                console.error('fileInput not found');
            }

            // Then do the rest of the reset (after file picker is triggered)
            startNewUpload();
        }

        function startNewUpload() {
            // Clear all cached data first
            clearAllCachedData();

            // Show upload section and model selection
            const uploadSection = document.getElementById('uploadSection');
            const modelSelection = document.getElementById('modelSelection');
            const dataViewer = document.getElementById('dataViewer');
            const cleaningPage = document.getElementById('cleaningPage');
            const featureEngineeringPage = document.getElementById('featureEngineeringPage');
            const visualizationPage = document.getElementById('visualizationPage');
            const result = document.getElementById('result');
            const newUploadBtn = document.getElementById('newUploadBtn');
            const uploadBtn = document.getElementById('uploadBtn');

            // Show upload UI
            if (uploadSection) {
                uploadSection.style.display = 'block';
                uploadSection.style.visibility = 'visible';
            }
            if (modelSelection) {
                modelSelection.style.display = 'block';
                modelSelection.style.visibility = 'visible';
            }

            // Hide all other sections
            if (dataViewer) {
                dataViewer.style.display = 'none';
                dataViewer.style.visibility = 'hidden';
            }
            if (cleaningPage) {
                cleaningPage.style.display = 'none';
                cleaningPage.style.visibility = 'hidden';
            }
            if (featureEngineeringPage) {
                featureEngineeringPage.style.display = 'none';
                featureEngineeringPage.style.visibility = 'hidden';
            }
            if (visualizationPage) {
                visualizationPage.style.display = 'none';
                visualizationPage.style.visibility = 'hidden';
            }
            if (result) {
                result.style.display = 'none';
            }
            if (newUploadBtn) {
                newUploadBtn.style.display = 'none';
            }
            if (uploadBtn) {
                uploadBtn.style.display = 'block';
            }

            // Reset form
            selectedFiles = [];
            selectedModelType = null;
            selectedModelAction = null;
            updateFileList();
            updateUploadButton(); // Update button state

            // Reset model selection visual state
            document.querySelectorAll('.model-option').forEach(option => {
                option.classList.remove('selected');
            });

            // Clear file input
            const fileInput = document.getElementById('fileInput');
            if (fileInput) {
                fileInput.value = '';
            }

            // Ensure upload button is visible and reset properly
            if (uploadBtn) {
                uploadBtn.style.display = 'block';
                uploadBtn.style.visibility = 'visible';
                uploadBtn.disabled = true; // Will be enabled when file/model selected
                uploadBtn.innerHTML = 'Upload & Process File';
                uploadBtn.style.background = 'linear-gradient(135deg, #10B981 0%, #34D399 100%)';
            }

            // Ensure file input is accessible
            const uploadBox = document.getElementById('uploadBox');
            if (uploadBox) {
                uploadBox.style.pointerEvents = 'auto';
            }

            console.log('Upload form reset complete.');
        }
        */ // End of commented upload functions - now in js/upload.js and js/utils.js

        // Data Viewer functions moved to frontend/js/dataViewer.js
        /* Data Viewer functions now in module:
        async function showDataTable(data) {
            const viewerContent = document.getElementById('viewerContent');

            // Check if data has been modified - if so, use existing allData
            if (dataModified && allData && allData.length > 0) {
                console.log('Data has been modified - using existing allData for viewer');
                const totalRows = allData.length;
                const totalCols = allColumns.length;
                showPaginatedData(allColumns, totalRows, totalCols);
                return;
            }

            viewerContent.innerHTML = `
                <div style="text-align: center; padding: 20px; color: #718096;">
                    <div class="spinner" style="margin: 0 auto 10px;"></div>
                    Loading data...
                </div>
            `;

            try {
                // Get the first file ID from uploaded files
                const fileId = data.file_ids[0];
                const response = await fetch(`http://localhost:8000/api/data/${fileId}`);

                if (response.ok) {
                    const fileData = await response.json();

                    if (fileData.type === 'tabular') {
                        // Store all data for pagination
                        allData = fileData.data;
                        const totalRows = fileData.shape[0];
                        const totalCols = fileData.shape[1];

                        // Store original columns for reference
                        uploadedData.original_columns = fileData.columns;

                        // Initialize allColumns with original columns if not already set
                        if (allColumns.length === 0) {
                            allColumns = fileData.columns;
                        }

                        // CRITICAL: Recalculate all engineered features after loading fresh data
                        console.log('Recalculating engineered features after loading data...');
                        recalculateAllEngineeredFeatures();

                        // Save allColumns to localStorage after features are recalculated
                        localStorage.setItem('allColumns', JSON.stringify(allColumns));
                        console.log('Saved allColumns to localStorage:', allColumns);

                        // Use updated allColumns array (includes new features) instead of just backend columns
                        const displayColumns = allColumns.length > fileData.columns.length ? allColumns : fileData.columns;

                        // Show paginated data with updated columns
                        showPaginatedData(displayColumns, totalRows, totalCols);
                    } else if (fileData.type === 'text') {
                        viewerContent.innerHTML = `
                            <div style="background: #f7fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 20px;">
                                <h4 style="margin-bottom: 15px; color: #2d3748;">üìÑ Text Content Preview</h4>
                                <pre style="white-space: pre-wrap; font-family: monospace; color: #4a5568;">${fileData.preview}</pre>
                            </div>
                            <p style="margin-top: 15px; color: #718096; font-size: 0.9rem;">
                                üìÑ Showing first 500 characters of text file.
                            </p>
                        `;
                    } else {
                        viewerContent.innerHTML = `
                            <div style="text-align: center; padding: 40px; color: #718096;">
                                <div style="font-size: 3rem; margin-bottom: 15px;">üìÅ</div>
                                <div>File type: ${fileData.type}</div>
                                <div style="font-size: 0.9rem; margin-top: 5px;">Preview not available for this file type</div>
                            </div>
                        `;
                    }
                } else {
                    throw new Error('Failed to load data');
                }
            } catch (error) {
                console.error('Error loading data:', error);
                // Only show error if this was triggered by an actual upload, not data restoration
                if (window.isUploadInProgress) {
                    viewerContent.innerHTML = `
                        <div style="text-align: center; padding: 40px; color: #e53e3e;">
                            <div style="font-size: 3rem; margin-bottom: 15px;">‚ùå</div>
                            <div>Error loading data: ${error.message}</div>
                        </div>
                    `;
                } else {
                    // For data restoration, just show a clean state
                    viewerContent.innerHTML = `
                        <div style="text-align: center; padding: 40px; color: #718096;">
                            <div style="font-size: 3rem; margin-bottom: 15px;"></div>
                            <div>Ready to upload data</div>
                        </div>
                    `;
                }
            }
        }

        function showImageBrowser(data) {
            const viewerContent = document.getElementById('viewerContent');

            // Mock folder structure for demo
            const mockFolders = [
                {
                    name: 'patient_001', type: 'folder', children: [
                        { name: 'scan_001.jpg', type: 'image' },
                        { name: 'scan_002.jpg', type: 'image' }
                    ]
                },
                {
                    name: 'patient_002', type: 'folder', children: [
                        { name: 'scan_003.jpg', type: 'image' },
                        { name: 'scan_004.jpg', type: 'image' }
                    ]
                },
                {
                    name: 'patient_003', type: 'folder', children: [
                        { name: 'scan_005.jpg', type: 'image' }
                    ]
                }
            ];

            viewerContent.innerHTML = `
                <div class="folder-browser">
                    <div class="folder-tree">
                        <h4 style="margin-bottom: 15px; color: #2d3748;">üìÅ Image Folders</h4>
                        ${renderFolderTree(mockFolders)}
                    </div>
                    <div class="image-preview" id="imagePreview">
                        <div style="color: #718096;">
                            üñºÔ∏è Click on an image to view it here
                        </div>
                    </div>
                </div>
            `;

            // Add click handlers
            document.querySelectorAll('.folder-item').forEach(item => {
                item.addEventListener('click', () => {
                    // Remove previous selection
                    document.querySelectorAll('.folder-item').forEach(i => i.classList.remove('selected'));
                    // Add selection to clicked item
                    item.classList.add('selected');

                    if (item.dataset.type === 'image') {
                        showImagePreview(item.dataset.name);
                    }
                });
            });
        }

        function renderFolderTree(folders, level = 0) {
            return folders.map(folder => {
                const indent = '  '.repeat(level);
                if (folder.type === 'folder') {
                    return `
                        <div class="folder-item" style="margin-left: ${level * 20}px;">
                            <span class="folder-icon">üìÅ</span>
                            ${folder.name}
                        </div>
                        ${folder.children ? renderFolderTree(folder.children, level + 1) : ''}
                    `;
                } else {
                    return `
                        <div class="folder-item" style="margin-left: ${level * 20}px;" data-type="image" data-name="${folder.name}">
                            <span class="folder-icon">üñºÔ∏è</span>
                            ${folder.name}
                        </div>
                    `;
                }
            }).join('');
        }

        function showImagePreview(imageName) {
            const imagePreview = document.getElementById('imagePreview');

            // Mock image preview - in real implementation, you'd load actual images
            imagePreview.innerHTML = `
                <div style="width: 100%; height: 300px; background: #f7fafc; border: 2px dashed #cbd5e0; border-radius: 8px; display: flex; align-items: center; justify-content: center; color: #718096;">
                    <div style="text-align: center;">
                        <div style="font-size: 3rem; margin-bottom: 15px;">üñºÔ∏è</div>
                        <div>${imageName}</div>
                        <div style="font-size: 0.8rem; margin-top: 5px;">Image preview would load here</div>
                    </div>
                </div>
                <div class="image-info">
                    <strong>File:</strong> ${imageName}<br>
                    <strong>Size:</strong> 1.2 MB<br>
                    <strong>Format:</strong> JPEG
                </div>
            `;
        }

        function startNewUpload() {
            // Reset everything for a new upload
            selectedFiles = [];
            selectedModelType = null;
            selectedModelAction = null;
            uploadedData = null;

            // Clear localStorage
            localStorage.removeItem('uploadedData');

            // Reset UI
            updateFileList();
            updateUploadButton();
            document.querySelectorAll('.model-option').forEach(option => {
                option.classList.remove('selected');
            });

            // Reset buttons
            document.getElementById('uploadBtn').style.display = 'block';
            document.getElementById('uploadBtn').disabled = true;
            document.getElementById('uploadBtn').innerHTML = 'Upload & Process File';
            document.getElementById('newUploadBtn').style.display = 'none';

            // Clear file input
            document.getElementById('fileInput').value = '';

            // Hide results and data viewer
            document.getElementById('result').style.display = 'none';
            document.getElementById('dataViewer').style.display = 'none';
        }

        function showPaginatedData(columns, totalRows, totalCols) {
            const viewerContent = document.getElementById('viewerContent');
            const startIndex = (currentPage - 1) * rowsPerPage;
            const endIndex = Math.min(startIndex + rowsPerPage, totalRows);
            const pageData = allData.slice(startIndex, endIndex);

            const headers = columns.map(col => `<th>${col}</th>`).join('');

            // Debug: check if the yes column has data
            if (columns.includes('yes') && pageData.length > 0) {
                console.log('Debug: Checking yes column data in table:');
                console.log('First row yes value:', pageData[0]['yes']);
                console.log('First 5 rows yes values:', pageData.slice(0, 5).map(row => row['yes']));
            }

            const rows = pageData.map((row, index) => `
                <tr>
                    <td>${startIndex + index + 1}</td>
                    ${columns.map(col => `<td>${row[col] !== undefined ? row[col] : ''}</td>`).join('')}
                </tr>
            `).join('');

            const totalPages = Math.ceil(totalRows / rowsPerPage);

            // Use actual column count from allColumns instead of backend totalCols
            const actualColCount = allColumns.length;

            viewerContent.innerHTML = `
                <div class="table-container">
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th>Row</th>
                                ${headers}
                            </tr>
                        </thead>
                        <tbody>
                            ${rows}
                        </tbody>
                    </table>
                </div>
                <div class="pagination-controls">
                    <div class="pagination-info">
                        Showing ${startIndex + 1}-${endIndex} of ${totalRows} rows √ó ${actualColCount} columns
                    </div>
                    <div class="pagination-buttons">
                        <button class="pagination-btn" onclick="changePage(1)" ${currentPage === 1 ? 'disabled' : ''}>
                            First
                        </button>
                        <button class="pagination-btn" onclick="changePage(${currentPage - 1})" ${currentPage === 1 ? 'disabled' : ''}>
                            Previous
                        </button>
                        <span style="padding: 8px 16px; color: #1E40AF; font-weight: 500;">
                            Page ${currentPage} of ${totalPages}
                        </span>
                        <button class="pagination-btn" onclick="changePage(${currentPage + 1})" ${currentPage === totalPages ? 'disabled' : ''}>
                            Next
                        </button>
                        <button class="pagination-btn" onclick="changePage(${totalPages})" ${currentPage === totalPages ? 'disabled' : ''}>
                            Last
                        </button>
                    </div>
                </div>
                <div style="margin-top: 15px; display: flex; justify-content: space-between; align-items: center;">
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <span style="color: #64748B;">Rows per page:</span>
                        <select onchange="changeRowsPerPage(this.value)" style="padding: 4px 8px; border: 1px solid #87CEEB; border-radius: 4px; color: #1E40AF;">
                            <option value="25" ${rowsPerPage === 25 ? 'selected' : ''}>25</option>
                            <option value="50" ${rowsPerPage === 50 ? 'selected' : ''}>50</option>
                            <option value="100" ${rowsPerPage === 100 ? 'selected' : ''}>100</option>
                            <option value="200" ${rowsPerPage === 200 ? 'selected' : ''}>200</option>
                        </select>
                    </div>
                </div>
                
                <!-- Navigation Button -->
        <div style="position: fixed; bottom: 20px; right: 20px; z-index: 1000;">
            <button onclick="proceedToCleaning()" style="background: linear-gradient(135deg, #3B82F6 0%, #87CEEB 100%); color: white; border: none; padding: 12px 24px; border-radius: 12px; font-weight: 600; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 4px 8px rgba(59, 130, 246, 0.3);" id="cleanDatasetBtn">
                Clean Dataset
            </button>
        </div>
        `;

            // Add event listener to the clean dataset button
            setTimeout(() => {
                const cleanBtn = document.getElementById('cleanDatasetBtn');
                if (cleanBtn) {
                    cleanBtn.addEventListener('click', (e) => {
                        console.log('Clean Dataset button clicked');
                        proceedToCleaning();
                    });
                }
            }, 100);
        }

        function changePage(page) {
            currentPage = page;
            // Re-render the data viewer with new page
            if (uploadedData && uploadedData.file_ids && uploadedData.file_ids[0]) {
                const fileId = uploadedData.file_ids[0];
                fetch(`http://localhost:8000/api/data/${fileId}`)
                    .then(response => response.json())
            .then(fileData => {
                if (fileData.type === 'tabular') {
                    allData = fileData.data;
                    // Recalculate engineered features
                    recalculateAllEngineeredFeatures();
                    // Use allColumns instead of fileData.columns to include engineered features
                    showPaginatedData(allColumns.length > 0 ? allColumns : fileData.columns, fileData.shape[0], fileData.shape[1]);
                }
            });
            }
        }

        function changeRowsPerPage(newRowsPerPage) {
            rowsPerPage = parseInt(newRowsPerPage);
            currentPage = 1; // Reset to first page
            changePage(1);
        }
        * / / / End of commented data viewer functions - now in frontend / js / dataViewer.js

        // Data Cleaning functions moved to frontend/js/dataCleaning.js
        /* Data Cleaning functions now in module:
        async function proceedToCleaning() {
            // Hide all upload elements and data viewer, show only cleaning page
            const uploadSection = document.getElementById('uploadSection');
            const modelSelection = document.getElementById('modelSelection');
            const dataViewer = document.getElementById('dataViewer');
            const featureEngineeringPage = document.getElementById('featureEngineeringPage');
            const cleaningPage = document.getElementById('cleaningPage');
            const result = document.getElementById('result');
            const newUploadBtn = document.getElementById('newUploadBtn');

            // Force hide all sections except cleaning page
            if (uploadSection) {
                uploadSection.style.display = 'none';
                uploadSection.style.visibility = 'hidden';
            }
            if (modelSelection) {
                modelSelection.style.display = 'none';
                modelSelection.style.visibility = 'hidden';
            }
            if (dataViewer) {
                dataViewer.style.display = 'none';
                dataViewer.style.visibility = 'hidden';
            }
            if (featureEngineeringPage) {
                featureEngineeringPage.style.display = 'none';
                featureEngineeringPage.style.visibility = 'hidden';
            }
            if (result) {
                result.style.display = 'none';
                result.style.visibility = 'hidden';
            }
            if (newUploadBtn) {
                newUploadBtn.style.display = 'none';
                newUploadBtn.style.visibility = 'hidden';
            }
            if (cleaningPage) {
                cleaningPage.style.display = 'block';
                cleaningPage.style.visibility = 'visible';
            }

            // Load the cleaning interface
            await loadCleaningInterface();
        }

        // Global variables for variable cleaning - all moved to frontend/js/config.js

        // Restore uploaded data from localStorage on page load
        // Restoration functions moved to frontend/js/dataManager.js

        // Test function for debugging feature creation
        window.testFeatureCreation = function () {
            console.log('Testing feature creation...');
            if (!window.createdFeatures || !Array.isArray(window.createdFeatures)) {
                window.createdFeatures = [];
            }

            // Add a test feature
            const testFeature = {
                type: 'rule_based',
                variable: 'test_var',
                operator: '>',
                value: '100',
                feature_name: 'test_feature',
                created_at: new Date().toISOString()
            };

            window.createdFeatures.push(testFeature);
            console.log('Added test feature:', testFeature);
            console.log('Total features:', window.createdFeatures.length);

            updateCreatedFeaturesDisplay();
            alert('Test feature added! Check the Created Features section.');
        };

        // Debug function to check current state
        window.debugCurrentState = function () {
            console.log('=== DEBUG CURRENT STATE ===');
            console.log('uploadedData:', uploadedData);
            console.log('allColumns:', allColumns);
            console.log('allData length:', allData ? allData.length : 'null');
            console.log('createdFeatures:', window.createdFeatures);
            if (allData && allData.length > 0) {
                console.log('Sample row keys:', Object.keys(allData[0]));
                console.log('Sample row data:', allData[0]);

                // Check if the yes column exists in the data
                if (allData[0].hasOwnProperty('yes')) {
                    console.log('YES column exists in data!');
                    console.log('First 10 values of yes column:', allData.slice(0, 10).map(row => row.yes));
                } else {
                    console.log('YES column does NOT exist in data!');
                }
            }
            console.log('========================');
        };

        // Test function to create a new feature automatically
        window.testAutoFeature = function () {
            console.log('=== TESTING AUTOMATIC FEATURE CREATION ===');

            if (!allData || allData.length === 0) {
                console.error('No data available');
                return;
            }

            // Create a simple test feature
            const featureName = 'test_auto_feature';
            const variable = 'Year of diagnosis';
            const operator = '>';
            const value = '2015';

            console.log(`Creating feature: ${variable} ${operator} ${value} -> ${featureName}`);

            // Check if feature already exists
            if (allColumns.includes(featureName)) {
                console.log('Feature already exists, removing it first...');
                const index = allColumns.indexOf(featureName);
                allColumns.splice(index, 1);
                allData.forEach(row => delete row[featureName]);
            }

            // Add to allColumns
            allColumns.push(featureName);

            // Call the calculation function
            calculateAndAddRuleBasedFeature(variable, operator, value, featureName);

            console.log('=== AUTOMATIC FEATURE CREATION COMPLETE ===');
        };

        // Function to force refresh Data Cleaning interface
        window.refreshDataCleaning = function () {
            console.log('=== FORCING DATA CLEANING REFRESH ===');
            console.log('Current allColumns:', allColumns);
            console.log('allColumns length:', allColumns.length);

            if (allColumns.length > 0) {
                currentVariableIndex = 0;
                displayCleaningInterface();
                console.log('Data Cleaning interface refreshed');
            } else {
                console.log('No columns available to refresh');
            }
        };

        // Function to force refresh all interfaces
        window.refreshAllInterfaces = function () {
            console.log('=== FORCING REFRESH OF ALL INTERFACES ===');
            console.log('Current allColumns:', allColumns);
            console.log('allColumns length:', allColumns.length);

            // Refresh Dataset Viewer if visible
            const dataViewer = document.getElementById('dataViewer');
            if (dataViewer && dataViewer.style.display !== 'none') {
                console.log('Refreshing Dataset Viewer...');
                if (allData && allData.length > 0) {
                    const totalRows = allData.length;
                    showPaginatedData(allColumns, totalRows, allColumns.length);
                }
            }

            // Refresh Data Cleaning if visible
            const cleaningPage = document.getElementById('cleaningPage');
            if (cleaningPage && cleaningPage.style.display !== 'none') {
                console.log('Refreshing Data Cleaning...');
                currentVariableIndex = 0;
                displayCleaningInterface();
            }

            console.log('All interfaces refreshed');
        };

        // Test function to manually add yes column data
        window.testAddYesColumn = function () {
            console.log('Manually adding yes column data...');
            if (!allData || allData.length === 0) {
                console.error('No data available');
                return;
            }

            allData.forEach((row, index) => {
                const histologicValue = row['Histologic Type ICD-O-3'];
                if (histologicValue && histologicValue !== '' && histologicValue !== 'nan') {
                    const numericValue = parseFloat(histologicValue);
                    if (!isNaN(numericValue)) {
                        row.yes = numericValue > 1 ? 1 : 0;
                    } else {
                        row.yes = 0;
                    }
                } else {
                    row.yes = 0;
                }
            });

            console.log('Added yes column data to all rows');
            console.log('First 10 values:', allData.slice(0, 10).map(row => `${row['Histologic Type ICD-O-3']} -> ${row.yes}`));
        };

        // All restoration functions moved to frontend/js/dataManager.js
        // They are automatically called on page load by the module

        async function loadCleaningInterface() {
            // First, get the column information from the uploaded data
            if (!uploadedData || !uploadedData.file_ids || uploadedData.file_ids.length === 0) {
                alert('No data available for cleaning. Please upload a dataset first.');
                goBackToViewer();
                return;
            }

            // Show loading state
            const cleaningContent = document.getElementById('cleaningContent');
            cleaningContent.innerHTML = `
                <div style="text-align: center; padding: 40px;">
                    <div style="font-size: 2rem; margin-bottom: 20px;">‚è≥</div>
                    <h4 style="color: #1E40AF; margin-bottom: 15px;">Loading Dataset Information...</h4>
                    <p style="color: #64748B;">Getting column data for cleaning...</p>
                </div>
            `;

            try {
                // Check if data has been modified locally
                if (dataModified && allData && allData.length > 0) {
                    console.log('Data has been modified - using existing allData instead of fetching from backend');
                    console.log('Keeping existing allColumns with engineered features');

                    // CRITICAL: Recalculate all engineered features to ensure they're present
                    console.log('Recalculating engineered features for cleaning interface...');
                    recalculateAllEngineeredFeatures();

                    // Save allColumns to localStorage after features are recalculated
                    localStorage.setItem('allColumns', JSON.stringify(allColumns));
                    console.log('Saved allColumns to localStorage:', allColumns);

                    console.log('Final allColumns for cleaning:', allColumns);
                    console.log('allColumns length:', allColumns.length);
                    currentVariableIndex = 0;
                    displayCleaningInterface();
                } else {
                    // Get the first file ID from uploaded files
                    const fileId = uploadedData.file_ids[0];
                    const response = await fetch(`http://localhost:8000/api/data/${fileId}`);

                    if (response.ok) {
                        const fileData = await response.json();

                        if (fileData.type === 'tabular' && fileData.columns) {
                            console.log('Loading cleaning interface...');
                            console.log('Backend columns:', fileData.columns);
                            console.log('Current allColumns:', allColumns);

                            // Load fresh data from backend
                            allData = fileData.data;
                            console.log('Loaded fresh allData from backend, length:', allData.length);

                            // NEVER reset allColumns - always keep the current state with engineered features
                            console.log('Keeping existing allColumns with engineered features (NEVER reset)');

                            // CRITICAL: Recalculate all engineered features after loading fresh data
                            console.log('Recalculating engineered features for cleaning interface...');
                            recalculateAllEngineeredFeatures();

                            // Save allColumns to localStorage after features are recalculated
                            localStorage.setItem('allColumns', JSON.stringify(allColumns));
                            console.log('Saved allColumns to localStorage:', allColumns);

                            console.log('Final allColumns for cleaning:', allColumns);
                            console.log('allColumns length:', allColumns.length);
                            currentVariableIndex = 0;
                            displayCleaningInterface();
                        } else {
                            alert('Only tabular data can be cleaned. Your uploaded file is not a CSV/TSV file.');
                            goBackToViewer();
                        }
                    } else {
                        throw new Error('Failed to load data');
                    }
                }
            } catch (error) {
                console.error('Error loading cleaning interface:', error);
                alert('Failed to load dataset for cleaning. Please try again.');
                goBackToViewer();
            }
        }

        function displayCleaningInterface() {
            const cleaningContent = document.getElementById('cleaningContent');

            cleaningContent.innerHTML = `
                <div style="display: flex; flex-direction: column; height: calc(100vh - 120px); gap: 10px; padding: 15px;">
                    <!-- Horizontal Variable List -->
                    <div style="background: linear-gradient(135deg, #F8FEFF 0%, #E8F8FF 100%); border: 2px solid #87CEEB; border-radius: 12px; padding: 15px;">
                        <div style="margin-bottom: 10px;">
                            <h4 style="color: #1E40AF; font-size: 1.1rem; margin: 0;">Variables to Clean</h4>
                        </div>
                        <p style="color: #64748B; font-size: 0.85rem; margin-bottom: 10px;">
                            Click on any variable to start cleaning its values.
                        </p>
                        
                        <div style="display: flex; gap: 8px; overflow-x: auto; padding: 5px 0; scrollbar-width: thin;">
                            ${allColumns.map((column, index) => `
                                <div id="variable-${index}" onclick="selectVariable(${index})" 
                                     style="min-width: 160px; padding: 10px; border: 2px solid ${index === currentVariableIndex ? '#3B82F6' : '#E0F2FE'}; 
                                            border-radius: 8px; cursor: pointer; transition: all 0.3s ease; flex-shrink: 0;
                                            background: ${index === currentVariableIndex ? '#EBF8FF' : 'white'};
                                            ${index === currentVariableIndex ? 'box-shadow: 0 3px 8px rgba(59, 130, 246, 0.3);' : 'box-shadow: 0 1px 3px rgba(0,0,0,0.1);'}">
                                    <div style="font-weight: 600; color: #1E40AF; margin-bottom: 4px; font-size: 0.8rem; line-height: 1.2;">
                                        ${column}
                                    </div>
                                    <div style="font-size: 0.7rem; color: #64748B; margin-bottom: 6px;">
                                        Variable ${index + 1} of ${allColumns.length}
                                    </div>
                                    <div>
                                        <span class="sidebarVariableTypeBadge" style="background: #E0F2FE; color: #1E40AF; padding: 2px 6px; border-radius: 10px; font-size: 0.65rem; font-weight: 600;">
                                            CATEGORICAL
                                        </span>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                        
                    </div>
                    
                    <!-- Main content area -->
                    <div style="flex: 1; padding: 0; overflow: auto; background: white; min-width: 0; border-radius: 12px; border: 2px solid #E0F2FE;">
                        <div id="variableContent" style="width: 100%; padding: 20px;">
                            <div style="text-align: center; padding: 60px 20px; color: #64748B;">
                                <h2 style="color: #1E40AF; margin-bottom: 15px; font-size: 1.8rem; font-weight: 700;">Select a Variable to Clean</h2>
                                <p style="font-size: 1rem; margin-bottom: 30px; max-width: 500px; margin-left: auto; margin-right: auto; line-height: 1.5;">
                                    Click on any variable from the horizontal list above to start cleaning its values.
                                </p>
                                <div style="background: #F8FAFC; border: 1px solid #E2E8F0; border-radius: 8px; padding: 25px; max-width: 400px; margin: 0 auto;">
                                    <h4 style="color: #374151; margin-bottom: 15px; font-size: 1rem; font-weight: 600;">Available Actions:</h4>
                                    <div style="text-align: left; color: #6B7280; font-size: 0.9rem; line-height: 1.6;">
                                        <div style="margin-bottom: 8px;">‚Ä¢ Select/deselect values to include or exclude</div>
                                        <div style="margin-bottom: 8px;">‚Ä¢ Rename values for better clarity</div>
                    <div style="margin-bottom: 8px;">‚Ä¢ Remove leading zeros (01 to 1, 02 to 2)</div>
                                        <div style="margin-bottom: 8px;">‚Ä¢ View real statistics from your dataset</div>
                                        <div style="margin-bottom: 0;">‚Ä¢ All variables default to categorical</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Navigation Buttons -->
                    <div style="position: fixed; bottom: 20px; left: 20px; right: 20px; display: flex; justify-content: space-between; gap: 15px; z-index: 1000;">
                        <div>
                            <button onclick="goBackToViewer()" style="background: #6B7280; color: white; border: none; padding: 12px 24px; border-radius: 8px; font-weight: 600; cursor: pointer;">
                                Back to Data Viewer
                            </button>
                        </div>
                        <div>
                            <button onclick="showFeatureEngineeringInterface()" style="background: linear-gradient(135deg, #059669 0%, #10B981 100%); color: white; border: none; padding: 12px 24px; border-radius: 8px; font-weight: 600; cursor: pointer;">
                                Feature Engineering
                            </button>
                        </div>
                    </div>
                    </div>
                    
                </div>
            `;
        }

        function selectVariable(index) {
            currentVariableIndex = index;
            updateSidebarSelection();
            loadCurrentVariable();
        }

        function updateSidebarSelection() {
            // Update the sidebar to show which variable is selected
            for (let i = 0; i < allColumns.length; i++) {
                const element = document.getElementById(`variable-${i}`);
                if (element) {
                    if (i === currentVariableIndex) {
                        element.style.borderColor = '#3B82F6';
                        element.style.background = '#EBF8FF';
                        element.style.boxShadow = '0 2px 8px rgba(59, 130, 246, 0.2)';
                    } else {
                        element.style.borderColor = '#E0F2FE';
                        element.style.background = 'white';
                        element.style.boxShadow = 'none';
                    }
                }
            }
        }

        function loadCurrentVariable() {
            const currentColumn = allColumns[currentVariableIndex];

            if (!currentColumn) {
                alert('No column data available');
                return;
            }

            // Show loading state in the main content area
            const variableContent = document.getElementById('variableContent');
            variableContent.innerHTML = `
                <div style="text-align: center; padding: 40px;">
                    <div style="font-size: 2rem; margin-bottom: 20px;">‚è≥</div>
                    <h4 style="color: #1E40AF; margin-bottom: 15px;">Loading Variable Data...</h4>
                    <p style="color: #64748B;">Analyzing ${currentColumn} values...</p>
                </div>
            `;

            // Fetch the actual data for this column to get value counts
            fetchColumnData(currentColumn);
        }

        async function fetchColumnData(column) {
            try {
                let columnData;

                // Check if we have saved changes for this variable
                if (variableChanges[column] && variableChanges[column].value_counts) {
                    // Full saved data exists
                    console.log('Loading saved changes for variable:', column);
                    columnData = variableChanges[column];
                } else if (variableChanges[column] && variableChanges[column].variable_type) {
                    // Only variable_type is saved, need to fetch fresh data but preserve the type
                    console.log('Variable type preserved for:', column, 'type:', variableChanges[column].variable_type);
                    // Fall through to calculate fresh data, then merge variable_type
                    if (allData && allData.length > 0) {
                        columnData = calculateLocalColumnData(column);
                        // Merge in the preserved variable_type
                        columnData.variable_type = variableChanges[column].variable_type;
                        // Save the merged data back
                        variableChanges[column] = JSON.parse(JSON.stringify(columnData));
                        localStorage.setItem('variableChanges', JSON.stringify(variableChanges));
                    } else {
                        // Fallback to backend
                        const fileId = uploadedData.file_ids[0];
                        const encodedColumn = encodeURIComponent(column);
                        const response = await fetch(`http://localhost:8000/api/column-analysis/${fileId}?column_name=${encodedColumn}`);
                        if (response.ok) {
                            columnData = await response.json();
                            // Merge in the preserved variable_type
                            columnData.variable_type = variableChanges[column].variable_type;
                            // Save the merged data back
                            variableChanges[column] = JSON.parse(JSON.stringify(columnData));
                            localStorage.setItem('variableChanges', JSON.stringify(variableChanges));
                        } else {
                            throw new Error('Failed to fetch column data');
                        }
                    }
                } else {
                    // Check if this is an engineered feature (not in original backend columns)
                    const originalColumns = uploadedData.original_columns || [];
                    const isEngineeredFeature = !originalColumns.includes(column);

                    if (allData && allData.length > 0) {
                        console.log('Calculating column data from allData for:', column);
                        // Always calculate from allData to get the latest changes
                        columnData = calculateLocalColumnData(column);
                    } else {
                        // Fallback to backend only if allData is not available
                        const fileId = uploadedData.file_ids[0];
                        const encodedColumn = encodeURIComponent(column);

                        const response = await fetch(`http://localhost:8000/api/column-analysis/${fileId}?column_name=${encodedColumn}`);

                        if (response.ok) {
                            columnData = await response.json();
                        } else {
                            throw new Error('Failed to fetch column data');
                        }
                    }
                }

                displayVariableCleaning(column, columnData);
            } catch (error) {
                console.error('Error fetching column data:', error);
                const variableContent = document.getElementById('variableContent');
                variableContent.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #EF4444;">
                        <div style="font-size: 2rem; margin-bottom: 20px;">‚ùå</div>
                        <h4 style="color: #EF4444; margin-bottom: 15px;">Failed to Load Variable Data</h4>
                        <p style="color: #64748B;">Error: ${error.message}</p>
                        <button onclick="loadCurrentVariable()" style="background: #3B82F6; color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; margin-top: 15px;">
                            üîÑ Try Again
                        </button>
                    </div>
                `;
            }
        }

        function displayVariableCleaning(column, columnData) {
            const variableContent = document.getElementById('variableContent');

            // Store the column data globally for this variable
            variableData = columnData;

            variableContent.innerHTML = `
                <div style="background: #fbfbfd; border: 1px solid #d2d2d7; border-radius: 14px; padding: 24px; margin-bottom: 24px;">
                    <h4 style="color: #1d1d1f; margin-bottom: 12px; font-size: 1.25rem; font-weight: 600; letter-spacing: -0.01em;">Variable Cleaning</h4>
                    <p style="color: #86868b; margin-bottom: 0; font-size: 0.9375rem;">
                        Clean and preprocess each variable in your dataset. Select/deselect values, rename them, and remove leading zeros.
                    </p>
                </div>

                <!-- Variable Navigation -->
                <div style="background: white; border: 1px solid #d2d2d7; border-radius: 14px; padding: 24px; margin-bottom: 24px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px;">
                        <div>
                            <h3 style="color: #1d1d1f; margin: 0; font-size: 1.5rem; font-weight: 600; letter-spacing: -0.02em;">${column}</h3>
                            <p style="color: #86868b; margin: 8px 0 0 0; font-size: 0.9375rem;">
                                Variable ${currentVariableIndex + 1} of ${allColumns.length}
                            </p>
                        </div>
                        
                        <div>
                            <span id="variableTypeBadge" style="background: #e8f0fe; color: #0071e3; padding: 8px 16px; border-radius: 20px; font-size: 0.875rem; font-weight: 600;">
                                CATEGORICAL
                            </span>
                        </div>
                    </div>
                </div>

                <!-- Variable Stats -->
                <div style="background: white; border: 1px solid #d2d2d7; border-radius: 14px; padding: 24px; margin-bottom: 24px;">
                    <h5 style="color: #1d1d1f; margin-bottom: 16px; font-weight: 600;">Variable Statistics</h5>
                    <div id="variableStatsContainer" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 16px;">
                        <div style="text-center p-3 bg-blue-50 rounded-lg">
                            <div id="totalValues" style="font-size: 1.5rem; font-weight: 600; color: #0071e3;">${columnData.total_values.toLocaleString()}</div>
                            <div style="font-size: 0.8125rem; color: #86868b;">Total Values</div>
                        </div>
                        <div style="text-center p-3 bg-green-50 rounded-lg">
                            <div id="uniqueValues" style="font-size: 1.5rem; font-weight: 600; color: #34c759;">${columnData.unique_values}</div>
                            <div style="font-size: 0.8125rem; color: #86868b;">Unique Values</div>
                        </div>
                        <div style="text-center p-3 bg-yellow-50 rounded-lg">
                            <div id="missingValues" style="font-size: 1.5rem; font-weight: 600; color: #ff9500;">${columnData.missing_count}</div>
                            <div style="font-size: 0.8125rem; color: #86868b;">Missing Values</div>
                        </div>
                    </div>
                </div>

                <!-- Bulk Actions -->
                <div style="background: #fbfbfd; border: 1px solid #d2d2d7; border-radius: 14px; padding: 24px; margin-bottom: 24px;">
                    <h5 style="color: #1d1d1f; margin-bottom: 16px; font-weight: 600;">Bulk Actions</h5>
                    <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                        <button onclick="selectAllValues()" style="background: #0071e3; color: white; border: none; padding: 8px 16px; border-radius: 8px; font-weight: 400; cursor: pointer; font-size: 0.875rem; transition: all 0.2s;" onmouseover="this.style.background='#0077ed'; this.style.transform='scale(1.02)';" onmouseout="this.style.background='#0071e3'; this.style.transform='scale(1)';">
                            Select All
                        </button>
                        <button onclick="deselectAllValues()" style="background: #86868b; color: white; border: none; padding: 8px 16px; border-radius: 8px; font-weight: 400; cursor: pointer; font-size: 0.875rem; transition: all 0.2s;" onmouseover="this.style.background='#a1a1a6'; this.style.transform='scale(1.02)';" onmouseout="this.style.background='#86868b'; this.style.transform='scale(1)';">
                            Deselect All
                        </button>
                        <button onclick="removeLeadingZeros()" style="background: #ff9500; color: white; border: none; padding: 8px 16px; border-radius: 8px; font-weight: 400; cursor: pointer; font-size: 0.875rem; transition: all 0.2s;" onmouseover="this.style.background='#ffad33'; this.style.transform='scale(1.02)';" onmouseout="this.style.background='#ff9500'; this.style.transform='scale(1)';">
                            Remove Leading Zeros
                        </button>
                        <button onclick="combineSelectedLabels()" style="background: #af52de; color: white; border: none; padding: 8px 16px; border-radius: 8px; font-weight: 400; cursor: pointer; font-size: 0.875rem; transition: all 0.2s;" onmouseover="this.style.background='#bf60e8'; this.style.transform='scale(1.02)';" onmouseout="this.style.background='#af52de'; this.style.transform='scale(1)';">
                            Combine Selected
                        </button>
                        <button onclick="setSelectedAsNaN()" style="background: #ff3b30; color: white; border: none; padding: 8px 16px; border-radius: 8px; font-weight: 400; cursor: pointer; font-size: 0.875rem; transition: all 0.2s;" onmouseover="this.style.background='#ff5040'; this.style.transform='scale(1.02)';" onmouseout="this.style.background='#ff3b30'; this.style.transform='scale(1)';">
                            Set Selected as NaN
                        </button>
                        <button onclick="resetAllNames()" style="background: #86868b; color: white; border: none; padding: 8px 16px; border-radius: 8px; font-weight: 400; cursor: pointer; font-size: 0.875rem; transition: all 0.2s;" onmouseover="this.style.background='#a1a1a6'; this.style.transform='scale(1.02)';" onmouseout="this.style.background='#86868b'; this.style.transform='scale(1)';">
                            Reset Names
                        </button>
                    </div>
                </div>

                <!-- Find and Replace -->
                <div style="background: #fffbf0; border: 1px solid #d2d2d7; border-radius: 14px; padding: 24px; margin-bottom: 24px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                        <h5 style="color: #1d1d1f; margin: 0; font-weight: 600;">Find and Replace</h5>
                        <button onclick="toggleFindReplace()" style="background: #86868b; color: white; border: none; padding: 4px 8px; border-radius: 6px; cursor: pointer; font-size: 0.8125rem;">
                            <span id="findReplaceToggle">‚àí</span>
                        </button>
                    </div>
                    
                    <div id="findReplaceContent">
                        <p style="color: #86868b; font-size: 0.875rem; margin-bottom: 16px;">
                            Replace text patterns across all values (e.g., "25 years" to "25", "Male" to "M")
                        </p>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 16px;">
                            <div>
                                <label style="display: block; margin-bottom: 6px; font-weight: 500; color: #1d1d1f; font-size: 0.875rem;">Find:</label>
                                <input type="text" id="findText" placeholder="e.g., ' years', 'Male', 'Female'" 
                                       style="width: 100%; padding: 8px 12px; border: 1px solid #d2d2d7; border-radius: 8px; background: white; font-size: 0.875rem;">
                            </div>
                            <div>
                                <label style="display: block; margin-bottom: 6px; font-weight: 500; color: #1d1d1f; font-size: 0.875rem;">Replace with:</label>
                                <input type="text" id="replaceText" placeholder="e.g., '', 'M', 'F'" 
                                       style="width: 100%; padding: 8px 12px; border: 1px solid #d2d2d7; border-radius: 8px; background: white; font-size: 0.875rem;">
                            </div>
                        </div>
                        
                        <div style="display: flex; gap: 16px; flex-wrap: wrap; margin-bottom: 16px;">
                            <label style="display: flex; align-items: center; gap: 6px; color: #1d1d1f; font-size: 0.875rem;">
                                <input type="checkbox" id="caseSensitive" style="transform: scale(1.1);">
                                Case sensitive
                            </label>
                            <label style="display: flex; align-items: center; gap: 6px; color: #1d1d1f; font-size: 0.875rem;">
                                <input type="checkbox" id="wholeWord" style="transform: scale(1.1);">
                                Whole word only
                            </label>
                            <label style="display: flex; align-items: center; gap: 6px; color: #1d1d1f; font-size: 0.875rem;">
                                <input type="checkbox" id="previewMode" checked style="transform: scale(1.1);">
                                Preview changes first
                            </label>
                        </div>
                        
                        <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                            <button onclick="performFindReplace()" style="background: #ff9500; color: white; border: none; padding: 8px 16px; border-radius: 8px; font-weight: 400; cursor: pointer; font-size: 0.875rem; transition: all 0.2s;" onmouseover="this.style.background='#ffad33'; this.style.transform='scale(1.02)';" onmouseout="this.style.background='#ff9500'; this.style.transform='scale(1)';">
                                Find & Replace
                            </button>
                            <button onclick="previewFindReplace()" style="background: #86868b; color: white; border: none; padding: 8px 16px; border-radius: 8px; font-weight: 400; cursor: pointer; font-size: 0.875rem; transition: all 0.2s;" onmouseover="this.style.background='#a1a1a6'; this.style.transform='scale(1.02)';" onmouseout="this.style.background='#86868b'; this.style.transform='scale(1)';">
                                Preview
                            </button>
                            <button onclick="clearFindReplace()" style="background: #ff3b30; color: white; border: none; padding: 8px 16px; border-radius: 8px; font-weight: 400; cursor: pointer; font-size: 0.875rem; transition: all 0.2s;" onmouseover="this.style.background='#ff5040'; this.style.transform='scale(1.02)';" onmouseout="this.style.background='#ff3b30'; this.style.transform='scale(1)';">
                                Clear
                            </button>
                        </div>
                        
                        <!-- Preview Results -->
                        <div id="findReplacePreview" style="display: none; margin-top: 16px; padding: 16px; background: white; border-radius: 8px; border: 1px solid #d2d2d7;">
                            <h6 style="color: #1d1d1f; margin-bottom: 12px; font-weight: 600;">Preview Changes:</h6>
                            <div id="previewResults"></div>
                            <div style="margin-top: 12px; display: flex; gap: 8px;">
                                <button onclick="applyFindReplace()" style="background: #34c759; color: white; border: none; padding: 6px 12px; border-radius: 6px; font-weight: 400; cursor: pointer; font-size: 0.875rem;" onmouseover="this.style.background='#30d158'" onmouseout="this.style.background='#34c759'">
                                    Apply Changes
                                </button>
                                <button onclick="cancelFindReplace()" style="background: #86868b; color: white; border: none; padding: 6px 12px; border-radius: 6px; font-weight: 400; cursor: pointer; font-size: 0.875rem;" onmouseover="this.style.background='#a1a1a6'" onmouseout="this.style.background='#86868b'">
                                    Cancel
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Values List -->
                <div style="background: white; border: 1px solid #E0F2FE; border-radius: 12px; padding: 25px; margin-bottom: 25px;">
                    <h5 style="color: #1E40AF; margin-bottom: 20px; font-weight: 600; font-size: 1.2rem;">üìã All Values (${columnData.value_counts.length} unique)</h5>
                    
                    <!-- Search Bar -->
                    <div style="margin-bottom: 15px;">
                        <input type="text" id="valueSearch" placeholder="üîç Search values..." 
                               style="width: 100%; padding: 10px 15px; border: 2px solid #87CEEB; border-radius: 8px; font-size: 1rem; background: white;"
                               oninput="filterValues(this.value)">
                    </div>
                    
                    <div id="valuesContainer" style="max-height: 500px; overflow-y: auto; border: 1px solid #F1F5F9; border-radius: 8px; padding: 15px; background: #FAFAFA;">
                        ${columnData.value_counts.map((item, index) => `
                            <div id="value-row-${index}" style="display: flex; align-items: center; padding: 15px; margin-bottom: 8px; border: 1px solid #E5E7EB; border-radius: 8px; background: white; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                                <input type="checkbox" id="select-${index}" checked onchange="updateValueSelection(${index})" 
                                       style="margin-right: 12px; transform: scale(1.2);">
                                
                                <div style="flex: 1; margin-right: 15px;">
                                    <div style="font-weight: 600; color: #1E40AF; margin-bottom: 4px; display: flex; align-items: center; gap: 8px;">
                                        <span>Original: <span style="background: #E0F2FE; padding: 2px 6px; border-radius: 4px; font-family: monospace;">${item.original_value}</span></span>
                                        <label style="display: flex; align-items: center; gap: 4px; margin-left: 12px; cursor: pointer;">
                                            <input type="checkbox" id="nan-${index}" onchange="toggleValueAsNaN(${index})" 
                                                   ${item.isNaN ? 'checked' : ''}
                                                   style="transform: scale(1.1);">
                                            <span style="font-size: 0.75rem; color: #ff9500; font-weight: 600;">Mark as NaN</span>
                                        </label>
                                    </div>
                                    <input type="text" id="name-${index}" value="${item.value}" onchange="updateValueName(${index})"
                                           style="width: 100%; padding: 6px 10px; border: 1px solid ${item.isNaN ? '#ff9500' : '#87CEEB'}; border-radius: 6px; font-family: monospace; background: ${item.isNaN ? '#fff8f0' : 'white'};">
                                </div>
                                
                                <div style="text-align: center;">
                                    <div style="background: #87CEEB; color: white; padding: 4px 12px; border-radius: 12px; font-weight: 600; font-size: 0.9rem;">
                                        ${item.count}
                                    </div>
                                    <div style="font-size: 0.7rem; color: #64748B; margin-top: 2px;">count</div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
                </div>

                <!-- Action Buttons -->
                <div style="display: flex; justify-content: center; align-items: center; gap: 12px; margin-top: 32px;">
                    <button onclick="saveVariableChanges()" style="background: #34c759; color: white; border: none; padding: 12px 32px; border-radius: 22px; font-weight: 400; cursor: pointer; font-size: 1rem; transition: all 0.2s;" onmouseover="this.style.background='#30d158'; this.style.transform='scale(1.02)';" onmouseout="this.style.background='#34c759'; this.style.transform='scale(1)';">
                        Save Changes
                    </button>
                    <button id="variableTypeToggleBtn" onclick="toggleVariableType()" style="background: #fbfbfd; color: #0071e3; border: 1px solid #d2d2d7; padding: 12px 32px; border-radius: 22px; font-weight: 400; cursor: pointer; transition: all 0.2s; font-size: 1rem;" onmouseover="this.style.borderColor='#0071e3'; this.style.transform='scale(1.02)';" onmouseout="this.style.borderColor='#d2d2d7'; this.style.transform='scale(1)';">
                        Set as Continuous
                    </button>
                </div>
            `;

            // Update the variable type badge and toggle button after displaying
            const savedType = variableChanges[columnData.column_name]?.variable_type || 'categorical';
            updateVariableTypeBadge(savedType);
            updateVariableTypeToggleButton(savedType);

            // Update all sidebar badges to reflect saved types
            updateAllSidebarBadges();
        }

        function generateMockValueCounts(column) {
            // Generate realistic mock data based on column name
            const mockData = {
                'age': [
                    { value: '25-34', count: 245 },
                    { value: '35-44', count: 198 },
                    { value: '45-54', count: 156 },
                    { value: '55-64', count: 134 },
                    { value: '18-24', count: 89 },
                    { value: '65+', count: 67 }
                ],
                'gender': [
                    { value: 'Female', count: 423 },
                    { value: 'Male', count: 387 },
                    { value: 'Other', count: 12 }
                ],
                'diagnosis': [
                    { value: 'Hypertension', count: 156 },
                    { value: 'Diabetes', count: 134 },
                    { value: 'Heart Disease', count: 89 },
                    { value: 'Asthma', count: 67 },
                    { value: 'COPD', count: 45 },
                    { value: 'Other', count: 329 }
                ],
                'medication': [
                    { value: 'Metformin', count: 89 },
                    { value: 'Lisinopril', count: 78 },
                    { value: 'Atorvastatin', count: 67 },
                    { value: 'Aspirin', count: 56 },
                    { value: 'None', count: 234 }
                ]
            };

            // Return mock data for known columns, or generate generic data
            if (mockData[column.toLowerCase()]) {
                return mockData[column.toLowerCase()];
            }

            // Generate generic mock data
            return [
                { value: 'Value A', count: Math.floor(Math.random() * 200) + 100 },
                { value: 'Value B', count: Math.floor(Math.random() * 150) + 80 },
                { value: 'Value C', count: Math.floor(Math.random() * 120) + 60 },
                { value: 'Value D', count: Math.floor(Math.random() * 100) + 40 },
                { value: 'Value E', count: Math.floor(Math.random() * 80) + 20 }
            ];
        }

        function previousVariable() {
            if (currentVariableIndex > 0) {
                saveVariableChangesToMemory();
                currentVariableIndex--;
                loadCurrentVariable();
            }
        }

        function nextVariable() {
            if (currentVariableIndex < allColumns.length - 1) {
                saveVariableChangesToMemory();
                currentVariableIndex++;
                loadCurrentVariable();
            }
        }

        function updateValueSelection(index) {
            // Update the selection status for a value
            const checkbox = document.getElementById(`select-${index}`);
            const row = document.getElementById(`value-row-${index}`);

            if (checkbox.checked) {
                row.style.opacity = '1';
                row.style.backgroundColor = index % 2 === 0 ? '#FAFAFA' : 'white';
            } else {
                row.style.opacity = '0.5';
                row.style.backgroundColor = '#FFE4E4';
            }


            // Update statistics
            updateVariableStats();

            // Save changes to memory
            saveVariableChangesToMemory();
        }

        function filterValues(searchTerm) {
            const container = document.getElementById('valuesContainer');
            const rows = container.querySelectorAll('[id^="value-row-"]');

            searchTerm = searchTerm.toLowerCase();

            rows.forEach((row, index) => {
                const valueText = variableData.value_counts[index].value.toLowerCase();
                const originalText = variableData.value_counts[index].original_value.toLowerCase();

                // Show row if search term matches current value or original value
                if (valueText.includes(searchTerm) || originalText.includes(searchTerm)) {
                    row.style.display = 'flex';
                } else {
                    row.style.display = 'none';
                }
            });
        }

        function updateValueName(index) {
            // Update the name of a value
            const input = document.getElementById(`name-${index}`);
            variableData.value_counts[index].value = input.value;

            // Update statistics
            updateVariableStats();

            // Save changes to memory
            saveVariableChangesToMemory();
        }

        function toggleValueAsNaN(index) {
            // Toggle the NaN status for a value
            const checkbox = document.getElementById(`nan-${index}`);
            const input = document.getElementById(`name-${index}`);

            variableData.value_counts[index].isNaN = checkbox.checked;

            // Update the input styling to show NaN status
            if (checkbox.checked) {
                input.style.borderColor = '#ff9500';
                input.style.background = '#fff8f0';
            } else {
                input.style.borderColor = '#87CEEB';
                input.style.background = 'white';
            }

            // Update statistics
            updateVariableStats();

            // Save changes to memory
            saveVariableChangesToMemory();
        }

        function selectAllValues() {
            // Select all values
            for (let i = 0; i < variableData.value_counts.length; i++) {
                const checkbox = document.getElementById(`select-${i}`);
                if (checkbox) {
                    checkbox.checked = true;
                    updateValueSelection(i);
                }
            }
        }

        function deselectAllValues() {
            // Deselect all values
            for (let i = 0; i < variableData.value_counts.length; i++) {
                const checkbox = document.getElementById(`select-${i}`);
                if (checkbox) {
                    checkbox.checked = false;
                    updateValueSelection(i);
                }
            }
        }

        function removeLeadingZeros() {
            if (!variableData || !variableData.value_counts || variableData.value_counts.length === 0) {
                alert('No data available for leading zero removal');
                return;
            }

            // First check if there are any values with leading zeros (multi-character)
            let hasLeadingZeros = false;
            for (let i = 0; i < variableData.value_counts.length; i++) {
                const originalValue = variableData.value_counts[i].value;
                if (/^0+/.test(originalValue) && originalValue.length > 1) {
                    hasLeadingZeros = true;
                    break;
                }
            }

            // If no leading zeros found, don't do anything
            if (!hasLeadingZeros) {
                return;
            }

            // Create a backup of the original data
            const originalData = JSON.parse(JSON.stringify(variableData.value_counts));

            // Remove leading zeros from all values and combine duplicates
            let updatedCount = 0;
            const valueMap = new Map();

            for (let i = 0; i < variableData.value_counts.length; i++) {
                const item = variableData.value_counts[i];
                const originalValue = item.value;
                let newValue = originalValue;

                // Get the actual checkbox state from the UI
                const checkbox = document.getElementById(`select-${i}`);
                const isSelected = checkbox ? checkbox.checked : false;

                // Check if value starts with 0 and has multiple characters
                if (/^0+/.test(originalValue) && originalValue.length > 1) {
                    // Remove all leading zeros, but keep at least one character
                    newValue = originalValue.replace(/^0+/, '') || '0';
                    updatedCount++;
                }

                // Use the exact newValue as the key to avoid case issues
                if (valueMap.has(newValue)) {
                    // Combine counts and preserve selection state
                    const existing = valueMap.get(newValue);
                    existing.count += item.count;
                    existing.selected = existing.selected || isSelected;
                } else {
                    // Create new entry
                    valueMap.set(newValue, {
                        value: newValue,
                        count: item.count,
                        original_value: item.original_value || originalValue,
                        selected: isSelected
                    });
                }
            }

            // Convert map back to array
            const newValueCounts = Array.from(valueMap.values());

            // Validate the new data before applying
            if (newValueCounts.length === 0) {
                variableData.value_counts = originalData;
                alert('Error: All values were lost during processing. Changes have been reverted.');
                return;
            }

            // Apply the changes
            variableData.value_counts = newValueCounts;

            // Re-display the interface to show the updated values
            displayVariableCleaning(variableData.column_name, variableData);

            // Update statistics
            updateVariableStats();

            // Save changes to memory
            saveVariableChangesToMemory();
        }

        function resetAllNames() {
            // Reset all names to original values
            if (confirm('Are you sure you want to reset all names to their original values?')) {
                for (let i = 0; i < variableData.value_counts.length; i++) {
                    const item = variableData.value_counts[i];
                    item.value = item.original_value;

                    // Update the input field
                    const input = document.getElementById(`name-${i}`);
                    if (input) {
                        input.value = item.original_value;
                    }
                }

                // Update statistics
                updateVariableStats();

                // Save changes to memory
                saveVariableChangesToMemory();

                // Silently complete the operation - no popup unless there's an error
            }
        }

        function combineSelectedLabels() {
            // Get all selected values by checking checkboxes
            const selectedValues = [];
            for (let i = 0; i < variableData.value_counts.length; i++) {
                const checkbox = document.getElementById(`select-${i}`);
                if (checkbox && checkbox.checked) {
                    selectedValues.push({
                        index: i,
                        value: variableData.value_counts[i].value,
                        count: variableData.value_counts[i].count
                    });
                }
            }

            if (selectedValues.length < 2) {
                alert('Please select at least 2 values to combine.');
                return;
            }

            // Show dialog to enter new combined name
            const valueList = selectedValues.map(v => `${v.value} (${v.count} occurrences)`).join('\n');
            const combinedName = prompt(
                `You have selected ${selectedValues.length} values:\n\n${valueList}\n\nEnter the name for the combined value (you can use any name you want):`,
                selectedValues[0].value
            );

            if (combinedName === null || combinedName.trim() === '') {
                return; // User cancelled or entered empty name
            }

            const newCombinedName = combinedName.trim();

            // Calculate total count of all selected values
            const totalCount = selectedValues.reduce((sum, v) => sum + v.count, 0);

            // Get all original values that will be replaced (use original_value if available)
            const originalValuesToReplace = selectedValues.map(v => {
                const item = variableData.value_counts[v.index];
                return item.original_value || item.value;
            });
            const currentValuesToReplace = selectedValues.map(v => v.value);

            // Update the dataset - replace all selected values with the new combined name
            const currentColumn = variableData.column_name;
            if (allData && allData.length > 0) {
                let updatedCount = 0;
                allData.forEach(row => {
                    const cellValue = String(row[currentColumn]);
                    // Check both original values and current values to catch any renamed values
                    if (originalValuesToReplace.includes(cellValue) || currentValuesToReplace.includes(cellValue)) {
                        row[currentColumn] = newCombinedName;
                        updatedCount++;
                    }
                });
                console.log(`Updated ${updatedCount} rows with combined value "${newCombinedName}"`);

                // Mark data as modified
                dataModified = true;
                try {
                    localStorage.setItem('dataModified', 'true');
                } catch (error) {
                    console.error('Error saving dataModified:', error);
                }
            }

            // Create a new value_counts array with the combined value
            const newValueCounts = [];
            const originalValueKeys = new Set(originalValuesToReplace);

            for (let i = 0; i < variableData.value_counts.length; i++) {
                const checkbox = document.getElementById(`select-${i}`);
                const item = variableData.value_counts[i];

                if (!checkbox || !checkbox.checked) {
                    // Keep non-selected values
                    newValueCounts.push(item);
                }
                // Skip selected values - they're being combined
            }

            // Add the new combined value
            newValueCounts.push({
                value: newCombinedName,
                original_value: originalValuesToReplace[0], // Keep first original for reference
                count: totalCount,
                selected: true,
                isNaN: false
            });

            // Sort by count descending
            newValueCounts.sort((a, b) => b.count - a.count);

            // Update the data
            variableData.value_counts = newValueCounts;

            // Clear cached variable data so it recalculates from updated allData
            if (currentColumn && variableChanges[currentColumn]) {
                delete variableChanges[currentColumn];
                localStorage.setItem('variableChanges', JSON.stringify(variableChanges));
            }

            // Re-display the interface
            displayVariableCleaning(variableData.column_name, variableData);

            // Update statistics
            updateVariableStats();

            // Save changes to memory
            saveVariableChangesToMemory();

            // Silently complete the operation - no popup unless there's an error
        }

        function setSelectedAsNaN() {
            // Get all selected values by checking checkboxes
            const selectedValues = [];
            for (let i = 0; i < variableData.value_counts.length; i++) {
                const checkbox = document.getElementById(`select-${i}`);
                if (checkbox && checkbox.checked) {
                    selectedValues.push(variableData.value_counts[i]);
                }
            }

            if (selectedValues.length === 0) {
                alert('Please select at least one value to set as NaN.');
                return;
            }

            if (!confirm(`Set ${selectedValues.length} selected value(s) as NaN/Missing?\n\nThis will mark these values as missing data.`)) {
                return;
            }

            // Calculate total count of all selected values
            const totalCount = selectedValues.reduce((sum, v) => sum + v.count, 0);

            // Check if there's already a NaN entry
            let existingNaNIndex = -1;
            for (let i = 0; i < variableData.value_counts.length; i++) {
                if (variableData.value_counts[i].value === 'Missing/NaN' ||
                    variableData.value_counts[i].value.toLowerCase().includes('missing') ||
                    variableData.value_counts[i].value.toLowerCase().includes('nan')) {
                    existingNaNIndex = i;
                    break;
                }
            }

            // Create new array without selected values (check checkboxes)
            const newValueCounts = [];
            for (let i = 0; i < variableData.value_counts.length; i++) {
                const checkbox = document.getElementById(`select-${i}`);
                if (!checkbox || !checkbox.checked) {
                    newValueCounts.push(variableData.value_counts[i]);
                }
            }

            if (existingNaNIndex !== -1) {
                // Find the NaN entry in the new array and update its count
                for (let i = 0; i < newValueCounts.length; i++) {
                    if (newValueCounts[i].value === 'Missing/NaN' ||
                        newValueCounts[i].value.toLowerCase().includes('missing') ||
                        newValueCounts[i].value.toLowerCase().includes('nan')) {
                        newValueCounts[i].count += totalCount;
                        newValueCounts[i].selected = true;
                        break;
                    }
                }
            } else {
                // Create a new NaN entry
                const nanEntry = {
                    value: 'Missing/NaN',
                    count: totalCount,
                    original_value: 'Missing/NaN',
                    selected: true
                };
                newValueCounts.unshift(nanEntry); // Add NaN at the beginning
            }

            // Update the data
            variableData.value_counts = newValueCounts;

            // Re-display the interface
            displayVariableCleaning(variableData.column_name, variableData);

            // Update statistics
            updateVariableStats();

            // Save changes to memory
            saveVariableChangesToMemory();

            // Silently complete the operation - no popup unless there's an error
        }

        function saveVariableChangesToMemory() {
            // Save current variable data to memory so changes persist
            const currentColumn = allColumns[currentVariableIndex];
            if (currentColumn && variableData) {
                // Deep copy the current state
                const savedState = JSON.parse(JSON.stringify(variableData));

                // Preserve the variable_type if it was previously set
                if (variableChanges[currentColumn] && variableChanges[currentColumn].variable_type) {
                    savedState.variable_type = variableChanges[currentColumn].variable_type;
                    console.log(`Preserving variable_type: ${savedState.variable_type} for column ${currentColumn}`);
                }

                variableChanges[currentColumn] = savedState;

                // Save variable changes to localStorage
                localStorage.setItem('variableChanges', JSON.stringify(variableChanges));

                console.log('Saved changes to memory and localStorage for:', currentColumn);
            }
        }

        function showVariableTypeSelection() {
            if (!variableData) return;

            // Check if all selected values are numeric
            const selectedValues = variableData.value_counts.filter((item, index) => {
                const checkbox = document.getElementById(`select-${index}`);
                return checkbox && checkbox.checked;
            });

            const allNumeric = selectedValues.every(item => {
                const value = item.value.trim();
                return !isNaN(value) && !isNaN(parseFloat(value)) && isFinite(value);
            });

            // Create modal for variable type selection
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                background: rgba(0,0,0,0.5); display: flex; justify-content: center; 
                align-items: center; z-index: 1000;
            `;

            modal.innerHTML = `
                <div style="background: white; padding: 30px; border-radius: 16px; max-width: 500px; width: 90%;">
                    <h3 style="color: #1E40AF; margin-bottom: 20px; text-align: center;">Set Variable Type</h3>
                    <p style="color: #64748B; margin-bottom: 20px; text-align: center;">
                        Variable: <strong>${variableData.column_name}</strong>
                    </p>
                    
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 10px; font-weight: 600; color: #374151;">
                            <input type="radio" name="variableType" value="categorical" checked style="margin-right: 8px;">
                            üìã Categorical - For categories, labels, or discrete values
                        </label>
                        <label style="display: block; margin-bottom: 10px; font-weight: 600; color: #374151;">
                    <input type="radio" name="variableType" value="continuous" ${!allNumeric ? 'disabled' : ''} style="margin-right: 8px;">
                    Continuous - For numeric values that can have decimals
                        </label>
                    </div>

                    ${!allNumeric ? `
                        <div style="background: #FEF2F2; border: 1px solid #FCA5A5; border-radius: 8px; padding: 12px; margin-bottom: 20px;">
                    <div style="color: #DC2626; font-weight: 600; margin-bottom: 5px;">Criteria Not Satisfied</div>
                            <div style="color: #7F1D1D; font-size: 0.9rem;">
                                Cannot set as continuous because some selected values are not numeric. 
                                Convert values to numeric format first.
                            </div>
                        </div>
                    ` : `
                        <div style="background: #F0FDF4; border: 1px solid #86EFAC; border-radius: 8px; padding: 12px; margin-bottom: 20px;">
                    <div style="color: #166534; font-weight: 600; margin-bottom: 5px;">Criteria Satisfied</div>
                            <div style="color: #14532D; font-size: 0.9rem;">
                                All selected values are numeric. You can set this as continuous.
                            </div>
                        </div>
                    `}

                    <div style="display: flex; gap: 10px; justify-content: center;">
                        <button onclick="closeVariableTypeModal()" style="background: #6B7280; color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer;">
                            Cancel
                        </button>
                        <button onclick="saveVariableType()" style="background: linear-gradient(135deg, #8B5CF6 0%, #A78BFA 100%); color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer;">
                            Save Type
                        </button>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);
        }

        function closeVariableTypeModal() {
            const modal = document.querySelector('div[style*="position: fixed"]');
            if (modal) modal.remove();
        }

        function toggleVariableType() {
            const currentColumn = allColumns[currentVariableIndex];
            const currentType = variableChanges[currentColumn]?.variable_type || 'categorical';
            const newType = currentType === 'categorical' ? 'continuous' : 'categorical';

            // Check if we can set as continuous (all selected values must be numeric)
            if (newType === 'continuous') {
                const canBeContinuous = checkIfCanBeContinuous();
                if (!canBeContinuous) {
                    alert('Cannot set as continuous: not all selected values are numeric.');
                    return;
                }
            }

            // Save the variable type
            if (!variableChanges[currentColumn]) {
                variableChanges[currentColumn] = JSON.parse(JSON.stringify(variableData));
            }
            variableChanges[currentColumn].variable_type = newType;

            // Convert data types in the actual dataset
            convertColumnDataType(currentColumn, newType);

            // Save variable changes to localStorage
            localStorage.setItem('variableChanges', JSON.stringify(variableChanges));

            // Update the badge display
            updateVariableTypeBadge(newType);

            // Update the toggle button
            updateVariableTypeToggleButton(newType);

            // Update sidebar badges
            updateAllSidebarBadges();
        }

        function convertColumnDataType(columnName, newType) {
            console.log(`Converting column "${columnName}" to ${newType} type`);

            if (!allData || allData.length === 0) {
                console.error('No data available for type conversion');
                return;
            }

            let convertedCount = 0;
            let invalidCount = 0;

            allData.forEach((row, index) => {
                const currentValue = row[columnName];

                if (currentValue === null || currentValue === undefined || currentValue === '') {
                    // Keep null/empty values as null
                    row[columnName] = null;
                    return;
                }

                if (newType === 'continuous') {
                    // Convert to numeric
                    const numericValue = parseFloat(currentValue);
                    if (!isNaN(numericValue)) {
                        // Determine if it should be integer or float
                        if (Number.isInteger(numericValue)) {
                            row[columnName] = parseInt(currentValue);
                        } else {
                            row[columnName] = numericValue;
                        }
                        convertedCount++;
                    } else {
                        // Keep as string if can't convert
                        row[columnName] = currentValue;
                        invalidCount++;
                    }
                } else if (newType === 'categorical') {
                    // Convert to string
                    row[columnName] = String(currentValue);
                    convertedCount++;
                }
            });

            console.log(`Converted ${convertedCount} values, ${invalidCount} invalid values`);
            console.log(`Sample converted values:`, allData.slice(0, 5).map(row => `${row[columnName]} (${typeof row[columnName]})`));

            // Update the global dataset reference
            if (window.originalDataset) {
                window.originalDataset = allData;
            }
        }

        function checkIfCanBeContinuous() {
            // Check if all selected values are numeric
            const valueCounts = variableData.value_counts || [];
            const selectedValues = valueCounts.filter(item => item.selected !== false);

            return selectedValues.every(item => {
                const value = item.value.toString().trim();
                return value === '' || !isNaN(value) && !isNaN(parseFloat(value));
            });
        }

        function updateVariableTypeToggleButton(variableType) {
            const toggleBtn = document.getElementById('variableTypeToggleBtn');
            if (!toggleBtn) return;

            if (variableType === 'continuous') {
                toggleBtn.textContent = 'Set as Categorical';
                toggleBtn.style.background = 'linear-gradient(135deg, #059669 0%, #10B981 100%)';
                toggleBtn.style.color = 'white';
                toggleBtn.style.border = '2px solid #10B981';
            } else {
                toggleBtn.textContent = 'Set as Continuous';
                toggleBtn.style.background = '#E0F2FE';
                toggleBtn.style.color = '#1E40AF';
                toggleBtn.style.border = '2px solid #B8E6FF';
            }
        }

        function updateVariableTypeBadge(variableType) {
            // Update the main badge
            const badge = document.getElementById('variableTypeBadge');
            if (badge) {
                if (variableType === 'continuous') {
                    badge.textContent = 'CONTINUOUS';
                    badge.style.background = 'linear-gradient(135deg, #059669 0%, #10B981 100%)';
                    badge.style.color = 'white';
                } else {
                    badge.textContent = 'CATEGORICAL';
                    badge.style.background = '#E0F2FE';
                    badge.style.color = '#1E40AF';
                }
            }

            // Update the sidebar badge for the current variable
            const currentColumn = allColumns[currentVariableIndex];
            updateSidebarBadge(currentColumn, variableType);
        }

        function updateSidebarBadge(columnName, variableType) {
            // Find the sidebar badge for this specific column
            const sidebarBadges = document.querySelectorAll('.sidebarVariableTypeBadge');
            const currentColumnIndex = allColumns.indexOf(columnName);

            if (currentColumnIndex >= 0 && sidebarBadges[currentColumnIndex]) {
                const sidebarBadge = sidebarBadges[currentColumnIndex];

                if (variableType === 'continuous') {
                    sidebarBadge.textContent = 'CONTINUOUS';
                    sidebarBadge.style.background = 'linear-gradient(135deg, #059669 0%, #10B981 100%)';
                    sidebarBadge.style.color = 'white';
                } else {
                    sidebarBadge.textContent = 'CATEGORICAL';
                    sidebarBadge.style.background = '#E0F2FE';
                    sidebarBadge.style.color = '#1E40AF';
                }
            }
        }

        function updateAllSidebarBadges() {
            // Update all sidebar badges based on saved variable types
            allColumns.forEach((columnName, index) => {
                const savedType = variableChanges[columnName]?.variable_type;
                if (savedType) {
                    updateSidebarBadge(columnName, savedType);
                }
            });
        }


        // Feature Engineering functions moved to frontend/js/featureEngineering.js
        /* Feature Engineering functions now in module:
        function showFeatureEngineeringInterface() {
            // Hide all other elements and show only feature engineering page
            const uploadSection = document.getElementById('uploadSection');
            const modelSelection = document.getElementById('modelSelection');
            const dataViewer = document.getElementById('dataViewer');
            const cleaningPage = document.getElementById('cleaningPage');
            const featureEngineeringPage = document.getElementById('featureEngineeringPage');
            const visualizationPage = document.getElementById('visualizationPage');
            const result = document.getElementById('result');
            const newUploadBtn = document.getElementById('newUploadBtn');

            // Hide all sections except feature engineering
            if (uploadSection) {
                uploadSection.style.display = 'none';
                uploadSection.style.visibility = 'hidden';
            }
            if (modelSelection) {
                modelSelection.style.display = 'none';
                modelSelection.style.visibility = 'hidden';
            }
            if (dataViewer) {
                dataViewer.style.display = 'none';
                dataViewer.style.visibility = 'hidden';
            }
            if (cleaningPage) {
                cleaningPage.style.display = 'none';
                cleaningPage.style.visibility = 'hidden';
            }
            if (visualizationPage) {
                visualizationPage.style.display = 'none';
                visualizationPage.style.visibility = 'hidden';
            }
            if (result) {
                result.style.display = 'none';
                result.style.visibility = 'hidden';
            }
            if (newUploadBtn) {
                newUploadBtn.style.display = 'none';
                newUploadBtn.style.visibility = 'hidden';
            }
            if (featureEngineeringPage) {
                featureEngineeringPage.style.display = 'block';
                featureEngineeringPage.style.visibility = 'visible';
            }

            // Always re-initialize feature engineering interface to get latest variable types
            initializeFeatureEngineeringInterface();
        }

        async function initializeFeatureEngineeringInterface() {
            // Load current dataset data
            let currentColumns = [];
            if (uploadedData && uploadedData.file_ids && uploadedData.file_ids.length > 0) {
                try {
                    const fileId = uploadedData.file_ids[0];
                    const response = await fetch(`http://localhost:8000/api/data/${fileId}`);
                    if (response.ok) {
                        const fileData = await response.json();
                        if (fileData.type === 'tabular' && fileData.columns) {
                            currentColumns = fileData.columns;
                        }
                    }
                } catch (error) {
                    console.error('Error loading data for feature engineering:', error);
                }
            }

            // Get continuous variables for rule-based features
            const continuousVariables = currentColumns.filter(column =>
                variableChanges[column]?.variable_type === 'continuous'
            );

            // Create feature engineering interface
            const featureEngineeringHTML = `
                <div style="display: flex; height: 100vh;">
                    <!-- Sidebar -->
                    <div style="width: 300px; background: linear-gradient(135deg, #F8FAFC 0%, #F1F5F9 100%); border-right: 1px solid #E2E8F0; padding: 20px; overflow-y: auto;">
                        <h3 style="color: #1E40AF; margin-bottom: 20px; font-weight: 700;">Feature Engineering</h3>
                        
                        <div style="margin-bottom: 30px;">
                            <h4 style="color: #374151; margin-bottom: 15px; font-weight: 600;">Available Variables</h4>
                            <div id="availableVariables" style="space-y: 8px;">
                                ${currentColumns.map(column => {
                const varType = variableChanges[column]?.variable_type || 'categorical';
                const isContinuous = varType === 'continuous';
                return `
                                    <div style="background: white; border: 1px solid ${isContinuous ? '#10B981' : '#E5E7EB'}; border-radius: 8px; padding: 12px; margin-bottom: 8px;">
                                        <div style="font-weight: 600; color: #1F2937; font-size: 0.9rem;">${column}</div>
                                        <div style="font-size: 0.8rem; color: ${isContinuous ? '#059669' : '#6B7280'}; font-weight: 600;">
                                            ${varType.toUpperCase()}
                                        </div>
                                    </div>
                                    `;
            }).join('')}
                            </div>
                        </div>

                        <div style="margin-bottom: 30px;">
                            <h4 style="color: #374151; margin-bottom: 15px; font-weight: 600;">Created Features</h4>
                            <div id="createdFeatures" style="min-height: 100px; background: white; border: 1px solid #E5E7EB; border-radius: 8px; padding: 12px;">
                                <p style="color: #9CA3AF; font-size: 0.9rem; text-align: center;">No features created yet</p>
                            </div>
                        </div>
                    </div>

                    <!-- Main Content -->
                    <div style="flex: 1; padding: 30px; overflow-y: auto;">
                        <div style="max-width: 800px; margin: 0 auto;">
                            <h2 style="color: #1E40AF; margin-bottom: 30px; font-weight: 700;">Create New Features</h2>
                            
                            <!-- Rule-based Features -->
                            <div style="background: white; border: 1px solid #E5E7EB; border-radius: 12px; padding: 25px; margin-bottom: 25px;">
                                <h3 style="color: #374151; margin-bottom: 20px; font-weight: 600;">Rule-Based Features (Binary: 0/1)</h3>
                                <p style="color: #6B7280; margin-bottom: 20px; font-size: 0.9rem;">
                                    Create binary features based on conditions. Results will be 0 or 1 for each row.
                                    <br><strong>Note:</strong> Only continuous variables can be used for rule-based features.
                                </p>
                                
                                ${continuousVariables.length > 0 ? `
                                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr 1fr; gap: 15px; align-items: end; margin-bottom: 20px;">
                                    <div>
                                        <label style="display: block; font-weight: 600; color: #374151; margin-bottom: 5px;">Variable</label>
                                        <select id="ruleVariable" style="width: 100%; padding: 8px; border: 1px solid #D1D5DB; border-radius: 6px;">
                                            ${continuousVariables.map(column => `<option value="${column}">${column}</option>`).join('')}
                                        </select>
                                    </div>
                                    <div>
                                        <label style="display: block; font-weight: 600; color: #374151; margin-bottom: 5px;">Operator</label>
                                        <select id="ruleOperator" style="width: 100%; padding: 8px; border: 1px solid #D1D5DB; border-radius: 6px;">
                                            <option value=">">Greater than (>)</option>
                                            <option value="<">Less than (<)</option>
                                            <option value="=">Equals (=)</option>
                                            <option value=">=">Greater or equal (>=)</option>
                                            <option value="<=">Less or equal (<=)</option>
                                            <option value="!=">Not equal (!=)</option>
                                        </select>
                                    </div>
                                    <div>
                                        <label style="display: block; font-weight: 600; color: #374151; margin-bottom: 5px;">Value</label>
                                        <input type="number" id="ruleValue" placeholder="e.g., 25" style="width: 100%; padding: 8px; border: 1px solid #D1D5DB; border-radius: 6px;" step="any">
                                    </div>
                                    <div>
                                        <label style="display: block; font-weight: 600; color: #374151; margin-bottom: 5px;">Feature Name</label>
                                        <input type="text" id="ruleFeatureName" placeholder="e.g., age_over_25" style="width: 100%; padding: 8px; border: 1px solid #D1D5DB; border-radius: 6px;">
                                    </div>
                                    <div>
                                        <button id="createRuleBtn" style="background: linear-gradient(135deg, #3B82F6 0%, #1D4ED8 100%); color: white; border: none; padding: 10px 16px; border-radius: 6px; font-weight: 600; cursor: pointer; width: 100%;">
                                            Create
                                        </button>
                                    </div>
                                </div>
                                ` : `
                                <div style="background: #FEF3C7; border: 1px solid #F59E0B; border-radius: 8px; padding: 16px; margin-bottom: 20px;">
                                    <p style="color: #92400E; font-weight: 600; margin: 0;">
                                        No continuous variables available for rule-based features.
                                        <br>Go to Data Cleaning to set variables as continuous first.
                                    </p>
                                </div>
                                `}
                            </div>

                            <!-- Column Combination -->
                            <div style="background: white; border: 1px solid #E5E7EB; border-radius: 12px; padding: 25px; margin-bottom: 25px;">
                                <h3 style="color: #374151; margin-bottom: 20px; font-weight: 600;">Combine Columns</h3>
                                <p style="color: #6B7280; margin-bottom: 20px; font-size: 0.9rem;">
                                    Combine two columns into a new feature. Non-missing values will be preserved.
                                </p>
                                
                                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 15px; align-items: end; margin-bottom: 20px;">
                                    <div>
                                        <label style="display: block; font-weight: 600; color: #374151; margin-bottom: 5px;">Column A</label>
                                        <select id="combineColumnA" style="width: 100%; padding: 8px; border: 1px solid #D1D5DB; border-radius: 6px;">
                                            ${currentColumns.map(column => `<option value="${column}">${column}</option>`).join('')}
                                        </select>
                                    </div>
                                    <div>
                                        <label style="display: block; font-weight: 600; color: #374151; margin-bottom: 5px;">Column B</label>
                                        <select id="combineColumnB" style="width: 100%; padding: 8px; border: 1px solid #D1D5DB; border-radius: 6px;">
                                            ${currentColumns.map(column => `<option value="${column}">${column}</option>`).join('')}
                                        </select>
                                    </div>
                                    <div>
                                        <label style="display: block; font-weight: 600; color: #374151; margin-bottom: 5px;">Feature Name</label>
                                        <input type="text" id="combineFeatureName" placeholder="e.g., combined_feature" style="width: 100%; padding: 8px; border: 1px solid #D1D5DB; border-radius: 6px;">
                                    </div>
                                    <div>
                                        <button id="createCombinedBtn" style="background: linear-gradient(135deg, #8B5CF6 0%, #7C3AED 100%); color: white; border: none; padding: 10px 16px; border-radius: 6px; font-weight: 600; cursor: pointer; width: 100%;">
                                            Combine
                                        </button>
                                    </div>
                                </div>
                            </div>

                            <!-- Action Buttons -->
                            <div style="position: fixed; bottom: 20px; left: 20px; right: 20px; display: flex; justify-content: space-between; gap: 15px; z-index: 1000;">
                                <div style="display: flex; gap: 15px;">
                                    <button onclick="goBackToDataViewer()" style="background: #6B7280; color: white; border: none; padding: 12px 24px; border-radius: 8px; font-weight: 600; cursor: pointer;">
                                        Back to Data Viewer
                                    </button>
                                    <button onclick="goBackToCleaning()" style="background: #3B82F6; color: white; border: none; padding: 12px 24px; border-radius: 8px; font-weight: 600; cursor: pointer;">
                                        Back to Cleaning
                                    </button>
                                </div>
                                <div style="display: flex; gap: 15px;">
                                    <button onclick="showVisualizationInterface()" style="background: linear-gradient(135deg, #8B5CF6 0%, #7C3AED 100%); color: white; border: none; padding: 12px 24px; border-radius: 8px; font-weight: 600; cursor: pointer;">
                                        Visualization
                                    </button>
                                    <button onclick="proceedToModelTraining()" style="background: linear-gradient(135deg, #059669 0%, #047857 100%); color: white; border: none; padding: 12px 24px; border-radius: 8px; font-weight: 600; cursor: pointer;">
                                        Model Training
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            // Add to the feature engineering interface section
            const featureEngineeringContent = document.getElementById('featureEngineeringContent');
            if (featureEngineeringContent) {
                featureEngineeringContent.innerHTML = featureEngineeringHTML;

                // Attach event listeners to dynamically created buttons
                setTimeout(() => {
                    const createRuleBtn = document.getElementById('createRuleBtn');
                    const createCombineBtn = document.getElementById('createCombinedBtn');

                    console.log('Looking for buttons:', { createRuleBtn, createCombineBtn });

                    if (createRuleBtn) {
                        console.log('Attaching rule button listener');
                        createRuleBtn.addEventListener('click', function (e) {
                            e.preventDefault();
                            e.stopPropagation();
                            console.log('Rule button clicked via event listener!');
                            createRuleBasedFeature();
                        });
                    }
                    if (createCombineBtn) {
                        console.log('Attaching combine button listener');
                        createCombineBtn.addEventListener('click', function (e) {
                            e.preventDefault();
                            e.stopPropagation();
                            console.log('Combine button clicked via event listener!');
                            createCombinedFeature();
                        });
                    }
                }, 300);
            }
        }

        function createRuleBasedFeature() {
            console.log('createRuleBasedFeature called');
            const variable = document.getElementById('ruleVariable').value;
            const operator = document.getElementById('ruleOperator').value;
            const value = document.getElementById('ruleValue').value;
            const featureName = document.getElementById('ruleFeatureName').value;

            if (!variable || !operator || !value || !featureName) {
                alert('Please fill in all fields for rule-based feature creation.');
                return;
            }

            // Check if feature name already exists
            if (allColumns.includes(featureName)) {
                alert('A feature with this name already exists. Please choose a different name.');
                return;
            }

            // Validate that the rule will produce meaningful results
            if (!validateRuleBasedFeature(variable, operator, value)) {
                return; // Validation failed, error message already shown
            }

            // Create the rule-based feature
            const feature = {
                type: 'rule_based',
                variable: variable,
                operator: operator,
                value: value,
                feature_name: featureName,
                created_at: new Date().toISOString()
            };

            // Add to created features
            if (!window.createdFeatures || !Array.isArray(window.createdFeatures)) {
                window.createdFeatures = [];
            }
            window.createdFeatures.push(feature);
            console.log('Added feature to window.createdFeatures:', feature);
            console.log('Total features now:', window.createdFeatures.length);

            // Save to localStorage
            localStorage.setItem('createdFeatures', JSON.stringify(window.createdFeatures));
            console.log('Saved createdFeatures to localStorage');

            // Add to allColumns
            allColumns.push(featureName);

            // Save allColumns to localStorage immediately
            localStorage.setItem('allColumns', JSON.stringify(allColumns));
            console.log('Saved allColumns to localStorage after feature creation');

            // Calculate the actual feature values and add to dataset
            calculateAndAddRuleBasedFeature(variable, operator, value, featureName);

            // Update the interface
            console.log('Calling updateCreatedFeaturesDisplay...');
            updateCreatedFeaturesDisplay();
            updateAvailableVariablesDisplay();

            // Refresh cleaning interface if it's currently displayed
            refreshCleaningInterfaceIfVisible();

            // Refresh data viewer if it's currently displayed
            refreshDataViewerIfVisible();

            // Clear form
            document.getElementById('ruleValue').value = '';
            document.getElementById('ruleFeatureName').value = '';

            // Show success message and force update display
            alert(`Rule-based feature "${featureName}" created successfully!`);

            // Force a visual update
            setTimeout(() => {
                updateCreatedFeaturesDisplay();
            }, 100);
        }

        function createCombinedFeature() {
            console.log('createCombinedFeature called');
            const columnA = document.getElementById('combineColumnA').value;
            const columnB = document.getElementById('combineColumnB').value;
            const featureName = document.getElementById('combineFeatureName').value;

            if (!columnA || !columnB || !featureName) {
                alert('Please fill in all fields for column combination.');
                return;
            }

            if (columnA === columnB) {
                alert('Cannot combine a column with itself. Please select different columns.');
                return;
            }

            // Check if feature name already exists
            if (allColumns.includes(featureName)) {
                alert('A feature with this name already exists. Please choose a different name.');
                return;
            }

            // Validate that the columns can be safely combined
            if (!validateCombinedFeature(columnA, columnB)) {
                return; // Validation failed, error message already shown
            }

            // Create the combined feature
            const feature = {
                type: 'combined',
                column_a: columnA,
                column_b: columnB,
                feature_name: featureName,
                created_at: new Date().toISOString()
            };

            // Add to created features
            if (!window.createdFeatures || !Array.isArray(window.createdFeatures)) {
                window.createdFeatures = [];
            }
            window.createdFeatures.push(feature);

            // Save to localStorage
            localStorage.setItem('createdFeatures', JSON.stringify(window.createdFeatures));
            console.log('Saved createdFeatures to localStorage');

            // Add to allColumns
            allColumns.push(featureName);

            // Save allColumns to localStorage immediately
            localStorage.setItem('allColumns', JSON.stringify(allColumns));
            console.log('Saved allColumns to localStorage after feature creation');

            // Calculate the actual combined feature values and add to dataset
            calculateAndAddCombinedFeature(columnA, columnB, featureName);

            // Update the interface
            updateCreatedFeaturesDisplay();
            updateAvailableVariablesDisplay();

            // Refresh cleaning interface if it's currently displayed
            refreshCleaningInterfaceIfVisible();

            // Refresh data viewer if it's currently displayed
            refreshDataViewerIfVisible();

            // Clear form
            document.getElementById('combineFeatureName').value = '';

            alert(`Combined feature "${featureName}" created successfully!`);
        }

        function updateCreatedFeaturesDisplay() {
            console.log('updateCreatedFeaturesDisplay called');
            const container = document.getElementById('createdFeatures');
            console.log('Container found:', container);
            console.log('Created features:', window.createdFeatures);

            if (!container) {
                console.log('No container found!');
                return;
            }

            if (!window.createdFeatures || window.createdFeatures.length === 0) {
                console.log('No features to display');
                container.innerHTML = '<p style="color: #9CA3AF; font-size: 0.9rem; text-align: center;">No features created yet</p>';
                return;
            }

            console.log('Rendering', window.createdFeatures.length, 'features');

            container.innerHTML = window.createdFeatures.map((feature, index) => `
                <div style="background: #F8FAFC; border: 1px solid #E2E8F0; border-radius: 6px; padding: 10px; margin-bottom: 8px;">
                    <div style="font-weight: 600; color: #1F2937; font-size: 0.9rem;">${feature.feature_name}</div>
                    <div style="font-size: 0.8rem; color: #6B7280;">
                        ${feature.type === 'rule_based'
                    ? `${feature.variable} ${feature.operator} ${feature.value}`
                    : `${feature.column_a} + ${feature.column_b}`
                }
                    </div>
                    <div style="font-size: 0.7rem; color: #9CA3AF;">
                        ${new Date(feature.created_at).toLocaleTimeString()}
                    </div>
                </div>
            `).join('');
        }

        function updateAvailableVariablesDisplay() {
            const container = document.getElementById('availableVariables');
            if (!container) return;

            container.innerHTML = allColumns.map(column => `
                <div style="background: white; border: 1px solid #E5E7EB; border-radius: 8px; padding: 12px; margin-bottom: 8px;">
                    <div style="font-weight: 600; color: #1F2937; font-size: 0.9rem;">${column}</div>
                    <div style="font-size: 0.8rem; color: #6B7280;">
                        ${variableChanges[column]?.variable_type || 'categorical'}
                    </div>
                </div>
            `).join('');
        }

        function refreshCleaningInterfaceIfVisible() {
            // Check if cleaning interface is currently visible
            const cleaningPage = document.getElementById('cleaningPage');
            if (cleaningPage && cleaningPage.style.display !== 'none') {
                console.log('Refreshing cleaning interface with new columns...');
                // Re-render the variable list in the cleaning interface
                const variableListContainer = document.querySelector('#cleaningContent .variable-list');
                if (variableListContainer) {
                    variableListContainer.innerHTML = allColumns.map((column, index) => `
                        <div class="variable-card" onclick="selectVariable(${index})" style="min-width: 160px; padding: 10px; background: white; border: 1px solid #E5E7EB; border-radius: 8px; cursor: pointer; transition: all 0.2s; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                            <div style="font-weight: 600; color: #1F2937; font-size: 0.85rem; margin-bottom: 4px;">${column}</div>
                            <div style="font-size: 0.75rem; color: #6B7280;">
                                <span class="sidebarVariableTypeBadge" style="padding: 2px 6px; border-radius: 4px; font-size: 0.7rem; font-weight: 600;">
                                    ${variableChanges[column]?.variable_type || 'categorical'}
                                </span>
                            </div>
                        </div>
                    `).join('');

                    // Update sidebar badges
                    updateAllSidebarBadges();
                }
            }
        }

        function refreshDataViewerIfVisible() {
            // Check if data viewer is currently visible
            const dataViewer = document.getElementById('dataViewer');
            if (dataViewer && dataViewer.style.display !== 'none') {
                console.log('Refreshing data viewer with new columns...');
                // Re-render the data table with updated columns
                if (allData && allData.length > 0) {
                    const totalRows = allData.length;
                    const totalCols = allColumns.length;
                    showPaginatedData(allColumns, totalRows, totalCols);
                }
            }
        }

        function recalculateAllEngineeredFeatures() {
            console.log('=== RECALCULATING ALL ENGINEERED FEATURES ===');
            if (!window.createdFeatures || !Array.isArray(window.createdFeatures) || window.createdFeatures.length === 0) {
                console.log('No engineered features to recalculate');
                return;
            }

            console.log(`Recalculating ${window.createdFeatures.length} features...`);
            window.createdFeatures.forEach(feature => {
                if (feature.type === 'rule_based') {
                    const variable = feature.variable || feature.feature_name;
                    const operator = feature.operator;
                    const value = feature.value;
                    const featureName = feature.name || feature.feature_name;
                    console.log(`Recalculating: ${variable} ${operator} ${value} -> ${featureName}`);
                    calculateAndAddRuleBasedFeature(variable, operator, value, featureName);
                } else if (feature.type === 'combined') {
                    const columnA = feature.columnA || feature.column_a;
                    const columnB = feature.columnB || feature.column_b;
                    const featureName = feature.name || feature.feature_name;
                    console.log(`Recalculating combined: ${columnA} + ${columnB} -> ${featureName}`);
                    calculateAndAddCombinedFeature(columnA, columnB, featureName);
                }
            });
            console.log('=== RECALCULATION COMPLETE ===');
        }

        function validateCombinedFeature(columnA, columnB) {
            console.log(`Validating combined feature: ${columnA} + ${columnB}`);

            if (!allData || allData.length === 0) {
                alert('No data available to validate feature. Please upload a dataset first.');
                return false;
            }

            // Check if both columns exist
            const availableColumns = Object.keys(allData[0]);
            if (!availableColumns.includes(columnA)) {
                alert(`Column "${columnA}" not found in the dataset. Please check the column name.`);
                return false;
            }
            if (!availableColumns.includes(columnB)) {
                alert(`Column "${columnB}" not found in the dataset. Please check the column name.`);
                return false;
            }

            // Helper function to check if a value is NaN/missing
            const isNaN = (val) => {
                return val === null || val === undefined || val === '' || val === 'nan' || val === 'NaN';
            };

            // Check for conflicts: rows where both values are valid but different
            let conflictCount = 0;
            let bothNaNCount = 0;
            let oneValidCount = 0;
            let bothMatchCount = 0;

            for (let i = 0; i < allData.length; i++) {
                const row = allData[i];
                const valueA = row[columnA];
                const valueB = row[columnB];

                const isValidA = !isNaN(valueA);
                const isValidB = !isNaN(valueB);

                if (isValidA && isValidB) {
                    // Both values are valid
                    if (String(valueA) === String(valueB)) {
                        bothMatchCount++;
                    } else {
                        conflictCount++;
                    }
                } else if (!isValidA && !isValidB) {
                    // Both are NaN
                    bothNaNCount++;
                } else {
                    // One is valid, one is NaN - this is fine
                    oneValidCount++;
                }
            }

            console.log(`Validation results: conflicts=${conflictCount}, bothNaN=${bothNaNCount}, oneValid=${oneValidCount}, bothMatch=${bothMatchCount}`);

            // If there are any conflicts where both values are valid but different, reject
            if (conflictCount > 0) {
                alert(`Cannot combine columns: Found ${conflictCount} row(s) where both columns have different valid values.\n\nCombined features can only be created when:\n- One value is missing and the other has a value, OR\n- Both values are missing, OR\n- Both values match exactly.\n\nThese columns have conflicting values and cannot be safely combined.`);
                return false;
            }

            // If all rows have both NaN, warn that the result will be all NaN
            if (bothNaNCount === allData.length && conflictCount === 0 && oneValidCount === 0 && bothMatchCount === 0) {
                if (!confirm(`Warning: Both columns "${columnA}" and "${columnB}" are completely empty.\n\nThis will create a feature with all missing values. Continue anyway?`)) {
                    return false;
                }
            }

            return true;
        }

        function validateRuleBasedFeature(variable, operator, value) {
            console.log(`Validating rule-based feature: ${variable} ${operator} ${value}`);

            if (!allData || allData.length === 0) {
                alert('No data available to validate feature. Please upload a dataset first.');
                return false;
            }

            // Convert value to number for comparison
            const numericValue = parseFloat(value);
            if (isNaN(numericValue)) {
                alert('Invalid numeric value for comparison. Please enter a valid number.');
                return false;
            }

            // Try to find the variable with case-insensitive matching
            let actualVariableName = variable;
            const availableColumns = Object.keys(allData[0]);
            const matchingColumn = availableColumns.find(col =>
                col.toLowerCase().includes(variable.toLowerCase()) ||
                variable.toLowerCase().includes(col.toLowerCase())
            );

            if (!matchingColumn) {
                alert(`Variable "${variable}" not found in the dataset. Please check the variable name.`);
                return false;
            }

            if (matchingColumn !== variable) {
                console.log(`Found matching column: ${matchingColumn} (was looking for: ${variable})`);
                actualVariableName = matchingColumn;
            }

            // Check a sample of values to predict the outcome
            let trueCount = 0;
            let falseCount = 0;
            let validCount = 0;

            allData.forEach((row, index) => {
                const cellValue = row[actualVariableName];

                if (cellValue !== null && cellValue !== undefined && cellValue !== '' && cellValue !== 'nan') {
                    const cellNumeric = parseFloat(cellValue);

                    if (!isNaN(cellNumeric)) {
                        validCount++;
                        // Perform the comparison
                        switch (operator) {
                            case '>':
                                if (cellNumeric > numericValue) trueCount++; else falseCount++;
                                break;
                            case '>=':
                                if (cellNumeric >= numericValue) trueCount++; else falseCount++;
                                break;
                            case '<':
                                if (cellNumeric < numericValue) trueCount++; else falseCount++;
                                break;
                            case '<=':
                                if (cellNumeric <= numericValue) trueCount++; else falseCount++;
                                break;
                            case '==':
                                if (cellNumeric === numericValue) trueCount++; else falseCount++;
                                break;
                            case '!=':
                                if (cellNumeric !== numericValue) trueCount++; else falseCount++;
                                break;
                        }
                    }
                }
            });

            console.log(`Validation results: validCount=${validCount}, trueCount=${trueCount}, falseCount=${falseCount}`);

            // Warn if all values would be the same
            if (validCount > 0 && (trueCount === 0 || falseCount === 0)) {
                const result = trueCount > 0 ? 'true (1)' : 'false (0)';
                alert(`Warning: This rule would set ALL ${validCount} valid values to ${result}.\n\nThis feature would have no variation and may not be useful. Consider adjusting the rule or value.`);
                return false;
            }

            if (validCount === 0) {
                alert(`No valid numeric values found in "${actualVariableName}". Cannot create feature.`);
                return false;
            }

            return true;
        }

        function calculateAndAddRuleBasedFeature(variable, operator, value, featureName) {
            console.log(`Calculating rule-based feature: ${variable} ${operator} ${value} -> ${featureName}`);

            if (!allData || allData.length === 0) {
                console.error('No data available to calculate feature');
                return;
            }

            console.log(`allData length: ${allData.length}`);
            console.log(`Sample row keys:`, Object.keys(allData[0]));

            // Convert value to number for comparison
            const numericValue = parseFloat(value);
            if (isNaN(numericValue)) {
                console.error('Invalid numeric value for comparison');
                return;
            }

            console.log(`Looking for variable: ${variable}`);
            console.log(`First row has this variable:`, allData[0][variable]);
            console.log(`All available column names:`, Object.keys(allData[0]));

            // Try to find the variable with case-insensitive matching
            let actualVariableName = variable;
            const availableColumns = Object.keys(allData[0]);
            const matchingColumn = availableColumns.find(col =>
                col.toLowerCase().includes(variable.toLowerCase()) ||
                variable.toLowerCase().includes(col.toLowerCase())
            );

            if (matchingColumn && matchingColumn !== variable) {
                console.log(`Found matching column: ${matchingColumn} (was looking for: ${variable})`);
                actualVariableName = matchingColumn;
            }

            let calculatedCount = 0;
            let trueCount = 0;
            let falseCount = 0;
            let invalidCount = 0;

            // Calculate the feature values for each row
            allData.forEach((row, index) => {
                const cellValue = row[actualVariableName];
                let featureValue = 0; // Default to 0

                console.log(`Row ${index}: ${actualVariableName} = "${cellValue}" (type: ${typeof cellValue})`);

                if (cellValue !== null && cellValue !== undefined && cellValue !== '' && cellValue !== 'nan') {
                    // Convert cell value to number
                    const cellNumeric = parseFloat(cellValue);

                    console.log(`Row ${index}: parsed value = ${cellNumeric} (isNaN: ${isNaN(cellNumeric)})`);

                    if (!isNaN(cellNumeric)) {
                        // Perform the comparison
                        switch (operator) {
                            case '>':
                                featureValue = cellNumeric > numericValue ? 1 : 0;
                                break;
                            case '>=':
                                featureValue = cellNumeric >= numericValue ? 1 : 0;
                                break;
                            case '<':
                                featureValue = cellNumeric < numericValue ? 1 : 0;
                                break;
                            case '<=':
                                featureValue = cellNumeric <= numericValue ? 1 : 0;
                                break;
                            case '==':
                                featureValue = cellNumeric === numericValue ? 1 : 0;
                                break;
                            case '!=':
                                featureValue = cellNumeric !== numericValue ? 1 : 0;
                                break;
                            default:
                                featureValue = 0;
                        }
                        calculatedCount++;
                        if (featureValue === 1) trueCount++;
                        else falseCount++;

                        console.log(`Row ${index}: ${cellNumeric} ${operator} ${numericValue} = ${featureValue}`);
                    } else {
                        invalidCount++;
                        console.log(`Row ${index}: Invalid numeric value: ${cellValue}`);
                    }
                } else {
                    invalidCount++;
                    console.log(`Row ${index}: Empty/null value: ${cellValue}`);
                }

                // Add the calculated value to the row
                row[featureName] = featureValue;

                // Debug: verify the value was actually added
                if (index < 5) {
                    console.log(`Row ${index}: Added ${featureName} = ${featureValue}, row now has:`, row[featureName]);
                }
            });

            console.log(`Successfully calculated feature ${featureName} for ${allData.length} rows`);
            console.log(`Calculated values: ${calculatedCount}, True (1): ${trueCount}, False (0): ${falseCount}, Invalid: ${invalidCount}`);
            console.log(`Sample calculated values:`, allData.slice(0, 5).map(row => row[featureName]));

            // Verify the data was actually added to the dataset
            const hasFeature = allData[0].hasOwnProperty(featureName);
            console.log(`Verification: Does first row have ${featureName}?`, hasFeature);
            if (hasFeature) {
                console.log(`Verification: First row ${featureName} value:`, allData[0][featureName]);
            }

            // Force a complete data refresh to ensure all references are updated
            console.log('Forcing data refresh...');

            // Update the global dataset reference
            if (window.originalDataset) {
                window.originalDataset = allData;
            }

            // Force refresh all interfaces that might be using the data
            setTimeout(() => {
                console.log('Post-calculation verification:');
                console.log('allData[0] has yes?', allData[0].hasOwnProperty(featureName));
                console.log('allData[0].yes value:', allData[0][featureName]);
            }, 100);
        }

        function calculateAndAddCombinedFeature(columnA, columnB, featureName) {
            console.log(`Calculating combined feature: ${columnA} + ${columnB} -> ${featureName}`);

            if (!allData || allData.length === 0) {
                console.error('No data available to calculate combined feature');
                return;
            }

            // Calculate the combined feature values for each row
            allData.forEach((row, index) => {
                const valueA = row[columnA];
                const valueB = row[columnB];
                let combinedValue = null; // Default to null (missing)

                // Helper function to check if a value is NaN/missing
                const isNaN = (val) => {
                    return val === null || val === undefined || val === '' || val === 'nan' || val === 'NaN';
                };

                const isValidA = !isNaN(valueA);
                const isValidB = !isNaN(valueB);

                // Logic: If one is valid and the other is NaN, use the valid one
                // If both are valid, they should match (validated earlier) - use either
                // If both are NaN, leave as null
                if (isValidA && !isValidB) {
                    combinedValue = valueA;
                } else if (isValidB && !isValidA) {
                    combinedValue = valueB;
                } else if (isValidA && isValidB) {
                    // Both valid - use the first one (they should match per validation)
                    combinedValue = valueA;
                } else {
                    // Both are NaN - leave as null
                    combinedValue = null;
                }

                // Add the combined value to the row
                row[featureName] = combinedValue;
            });

            console.log(`Successfully calculated combined feature ${featureName} for ${allData.length} rows`);

            // Update the global dataset reference
            if (window.originalDataset) {
                window.originalDataset = allData;
            }
        }

        function calculateLocalColumnData(column) {
            console.log(`Calculating local column data for: ${column}`);

            if (!allData || allData.length === 0) {
                console.error('No data available for column calculation');
                return null;
            }

            // Count values for this column
            const valueCounts = {};
            let totalValues = 0;
            let missingValues = 0;

            // Debug: check first few rows for this column
            console.log(`Debug: First 5 rows for column ${column}:`);
            for (let i = 0; i < Math.min(5, allData.length); i++) {
                console.log(`Row ${i}: ${column} = "${allData[i][column]}" (type: ${typeof allData[i][column]})`);
            }

            allData.forEach(row => {
                const value = row[column];
                totalValues++;

                if (value === null || value === undefined || value === '') {
                    missingValues++;
                } else {
                    const stringValue = String(value);
                    valueCounts[stringValue] = (valueCounts[stringValue] || 0) + 1;
                }
            });

            console.log(`Debug: Column ${column} statistics:`);
            console.log(`- Total values: ${totalValues}`);
            console.log(`- Missing values: ${missingValues}`);
            console.log(`- Unique values: ${Object.keys(valueCounts).length}`);
            console.log(`- Value counts:`, valueCounts);
            console.log(`- Sample values processed:`, Object.keys(valueCounts).slice(0, 10));

            // Convert to the format expected by the cleaning interface
            const value_counts = Object.entries(valueCounts).map(([value, count]) => ({
                value: value,
                original_value: value, // Store original value for reference
                count: count,
                selected: true, // All values selected by default
                isNaN: false // Track if marked as NaN
            })).sort((a, b) => b.count - a.count); // Sort by count descending

            // Determine the actual data type from the first non-null value
            let actualDataType = 'string'; // Default
            if (allData.length > 0) {
                for (let i = 0; i < allData.length; i++) {
                    const value = allData[i][column];
                    if (value !== null && value !== undefined && value !== '') {
                        actualDataType = typeof value;
                        break;
                    }
                }
            }

            return {
                column_name: column,
                data_type: actualDataType,
                total_values: totalValues,
                unique_values: Object.keys(valueCounts).length,
                missing_values: missingValues,
                missing_count: missingValues, // Also include missing_count for compatibility
                value_counts: value_counts
            };
        }

        function goBackToDataViewer() {
            // Hide feature engineering page and show data viewer with upload section
            const featureEngineeringPage = document.getElementById('featureEngineeringPage');
            const cleaningPage = document.getElementById('cleaningPage');
            const uploadSection = document.getElementById('uploadSection');
            const modelSelection = document.getElementById('modelSelection');
            const dataViewer = document.getElementById('dataViewer');
            const result = document.getElementById('result');
            const newUploadBtn = document.getElementById('newUploadBtn');

            if (featureEngineeringPage) {
                featureEngineeringPage.style.display = 'none';
                featureEngineeringPage.style.visibility = 'hidden';
            }
            if (cleaningPage) {
                cleaningPage.style.display = 'none';
                cleaningPage.style.visibility = 'hidden';
            }
            if (uploadSection) {
                uploadSection.style.display = 'block';
                uploadSection.style.visibility = 'visible';
            }
            if (modelSelection) {
                modelSelection.style.display = 'block';
                modelSelection.style.visibility = 'visible';
            }
            if (dataViewer) {
                dataViewer.style.display = 'block';
                dataViewer.style.visibility = 'visible';
            }
            if (result) {
                result.style.display = 'block';
                result.style.visibility = 'visible';
            }
            if (newUploadBtn) {
                newUploadBtn.style.display = 'block';
                newUploadBtn.style.visibility = 'visible';
            }

            // Make sure data is still displayed if we have uploaded data
            if (uploadedData && uploadedData.file_ids && uploadedData.file_ids.length > 0) {
                showDataViewer(uploadedData);

                // Refresh data viewer to show any new features
                setTimeout(() => {
                    refreshDataViewerIfVisible();
                }, 100);
            }
        }

        function goBackToCleaning() {
            // Hide feature engineering page and show cleaning page only
            const featureEngineeringPage = document.getElementById('featureEngineeringPage');
            const uploadSection = document.getElementById('uploadSection');
            const modelSelection = document.getElementById('modelSelection');
            const dataViewer = document.getElementById('dataViewer');
            const cleaningPage = document.getElementById('cleaningPage');

            if (featureEngineeringPage) {
                featureEngineeringPage.style.display = 'none';
                featureEngineeringPage.style.visibility = 'hidden';
            }
            if (uploadSection) {
                uploadSection.style.display = 'none';
                uploadSection.style.visibility = 'hidden';
            }
            if (modelSelection) {
                modelSelection.style.display = 'none';
                modelSelection.style.visibility = 'hidden';
            }
            if (dataViewer) {
                dataViewer.style.display = 'none';
                dataViewer.style.visibility = 'hidden';
            }
            if (cleaningPage) {
                cleaningPage.style.display = 'block';
                cleaningPage.style.visibility = 'visible';
            }
        }
        */ // End of commented feature engineering functions - now in frontend/js/featureEngineering.js

        // Model Training functions moved to js/modelTraining.js module
        // Function definitions preserved there for modularity

        /* Model Training functions now in js/modelTraining.js
        function initializeModelTrainingInterface() {
            const modelTrainingContent = document.getElementById('modelTrainingContent');

            if (!allData || allData.length === 0 || !allColumns || allColumns.length === 0) {
                modelTrainingContent.innerHTML = `
                    <div style="text-align: center; padding: 60px 20px; color: #64748B;">
                        <h4 style="color: #1E40AF; margin-bottom: 15px;">No Data Available</h4>
                        <p style="font-size: 1rem; margin-bottom: 30px;">Please upload and prepare a dataset first.</p>
                        <button onclick="showDataViewer(uploadedData)" style="background: #6B7280; color: white; border: none; padding: 12px 24px; border-radius: 8px; font-weight: 600; cursor: pointer;">
                            Back to Data Viewer
                        </button>
                    </div>
                `;
                return;
            }

            // Get variable types for display
            const getVariableType = (column) => {
                return variableChanges[column]?.variable_type || 'categorical';
            };

            // Create model training interface
            const modelTrainingHTML = `
                <div style="display: flex; gap: 20px; padding: 20px; min-height: calc(100vh - 120px);">
                    <!-- Left Sidebar: Feature Selection -->
                    <div style="width: 350px; background: linear-gradient(135deg, #F8FAFC 0%, #F1F5F9 100%); border-radius: 16px; padding: 24px; border: 1px solid #E2E8F0;">
                        <h3 style="color: #1E40AF; margin-bottom: 20px; font-weight: 700;">Feature Selection</h3>
                        
                        <!-- Label Selection -->
                        <div style="margin-bottom: 30px;">
                            <label style="display: block; font-weight: 600; color: #374151; margin-bottom: 10px; font-size: 0.95rem;">
                                Select Label (Target Variable)
                            </label>
                            <select id="labelSelection" onchange="handleLabelSelection(this.value)" style="width: 100%; padding: 10px 14px; border: 1px solid #D1D5DB; border-radius: 10px; background: white; font-size: 0.95rem; cursor: pointer;">
                                <option value="">-- Select Label --</option>
                                ${allColumns.map(column => `<option value="${column}">${column}</option>`).join('')}
                            </select>
                        </div>

                        <!-- Feature Checkboxes -->
                        <div style="margin-bottom: 20px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                                <label style="font-weight: 600; color: #374151; font-size: 0.95rem;">Select Features</label>
                                <div style="display: flex; gap: 8px;">
                                    <button onclick="selectAllFeatures()" style="background: #0071e3; color: white; border: none; padding: 6px 12px; border-radius: 6px; font-size: 0.8rem; cursor: pointer; font-weight: 500;">
                                        Select All
                                    </button>
                                    <button onclick="deselectAllFeatures()" style="background: #86868b; color: white; border: none; padding: 6px 12px; border-radius: 6px; font-size: 0.8rem; cursor: pointer; font-weight: 500;">
                                        Deselect All
                                    </button>
                                </div>
                            </div>
                            <div style="max-height: 500px; overflow-y: auto; background: white; border-radius: 10px; padding: 12px; border: 1px solid #E5E7EB;">
                                ${allColumns.map((column, index) => {
                const varType = getVariableType(column);
                const isContinuous = varType === 'continuous';
                return `
                                        <label style="display: flex; align-items: center; gap: 12px; padding: 10px; border-radius: 8px; cursor: pointer; transition: background 0.2s; margin-bottom: 4px;" 
                                               onmouseover="this.style.background='#F9FAFB'" 
                                               onmouseout="this.style.background='transparent'">
                                            <input type="checkbox" id="feature-${index}" value="${column}" class="feature-checkbox" checked
                                                   style="width: 18px; height: 18px; cursor: pointer; accent-color: #0071e3;">
                                            <div style="flex: 1;">
                                                <div style="font-weight: 600; color: #1F2937; font-size: 0.9rem; margin-bottom: 2px;">${column}</div>
                                                <div style="font-size: 0.75rem; color: ${isContinuous ? '#059669' : '#6B7280'}; font-weight: 600;">
                                                    ${varType.toUpperCase()}
                                                </div>
                                            </div>
                                        </label>
                                    `;
            }).join('')}
                            </div>
                        </div>
                    </div>

                    <!-- Main Content Area -->
                    <div style="flex: 1; display: flex; flex-direction: column; gap: 20px;">
                        <!-- Action Buttons -->
                        <div style="background: white; border: 1px solid #E5E7EB; border-radius: 16px; padding: 24px;">
                            <h4 style="color: #1E40AF; margin-bottom: 20px; font-weight: 700;">Data Processing</h4>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                                <button onclick="convertCategoricalToNumerical()" 
                                        style="background: linear-gradient(135deg, #8B5CF6 0%, #7C3AED 100%); color: white; border: none; padding: 14px 20px; border-radius: 12px; font-weight: 600; cursor: pointer; font-size: 0.95rem; transition: all 0.2s;"
                                        onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(139, 92, 246, 0.3)'"
                                        onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                                    Convert Categorical to Numerical
                                </button>
                                <button onclick="saveEmbeddings()" 
                                        style="background: linear-gradient(135deg, #10B981 0%, #059669 100%); color: white; border: none; padding: 14px 20px; border-radius: 12px; font-weight: 600; cursor: pointer; font-size: 0.95rem; transition: all 0.2s;"
                                        onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(16, 185, 129, 0.3)'"
                                        onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                                    Save Embeddings
                                </button>
                                <button onclick="saveProcessedDataset()" 
                                        style="background: linear-gradient(135deg, #3B82F6 0%, #1D4ED8 100%); color: white; border: none; padding: 14px 20px; border-radius: 12px; font-weight: 600; cursor: pointer; font-size: 0.95rem; transition: all 0.2s;"
                                        onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(59, 130, 246, 0.3)'"
                                        onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                                    Save Dataset
                                </button>
                                <button onclick="previewTrainingDataset()" 
                                        style="background: linear-gradient(135deg, #F59E0B 0%, #D97706 100%); color: white; border: none; padding: 14px 20px; border-radius: 12px; font-weight: 600; cursor: pointer; font-size: 0.95rem; transition: all 0.2s;"
                                        onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(245, 158, 11, 0.3)'"
                                        onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                                    Preview Training Dataset
                                </button>
                            </div>
                        </div>

                        <!-- Dataset Viewer -->
                        <div style="background: white; border: 1px solid #E5E7EB; border-radius: 16px; padding: 24px; flex: 1; min-height: 400px;">
                            <h4 style="color: #1E40AF; margin-bottom: 20px; font-weight: 700;">Training Dataset Preview</h4>
                            <div id="trainingDatasetViewer" style="min-height: 300px;">
                                <div style="text-align: center; padding: 60px 20px; color: #9CA3AF;">
                                    <p style="font-size: 1.1rem;">Select features and label, then click "Preview Training Dataset" to see the processed data</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Navigation Buttons -->
                <div style="position: fixed; bottom: 20px; left: 20px; right: 20px; display: flex; justify-content: space-between; gap: 15px; z-index: 1000;">
                    <div>
                        <button onclick="showVisualizationInterface()" style="background: #6B7280; color: white; border: none; padding: 12px 24px; border-radius: 8px; font-weight: 600; cursor: pointer;">
                            Back to Visualization
                        </button>
                    </div>
                    <div>
                        <button onclick="proceedToActualTraining()" style="background: linear-gradient(135deg, #059669 0%, #047857 100%); color: white; border: none; padding: 12px 24px; border-radius: 8px; font-weight: 600; cursor: pointer;">
                            Start Training
                        </button>
                    </div>
                </div>
            `;

            modelTrainingContent.innerHTML = modelTrainingHTML;
        }

        function selectAllFeatures() {
            document.querySelectorAll('.feature-checkbox').forEach(checkbox => {
                checkbox.checked = true;
            });
        }

        function deselectAllFeatures() {
            document.querySelectorAll('.feature-checkbox').forEach(checkbox => {
                checkbox.checked = false;
            });
        }

        function handleLabelSelection(labelValue) {
            // Uncheck the label from feature selection if it's selected
            if (labelValue) {
                document.querySelectorAll('.feature-checkbox').forEach(checkbox => {
                    if (checkbox.value === labelValue) {
                        checkbox.checked = false;
                    }
                });
            }
        }

        function convertCategoricalToNumerical() {
            if (!allData || allData.length === 0) {
                alert('No data available to convert');
                return;
            }

            // Get all categorical columns
            const categoricalColumns = allColumns.filter(column => {
                const varType = variableChanges[column]?.variable_type || 'categorical';
                return varType === 'categorical';
            });

            if (categoricalColumns.length === 0) {
                alert('No categorical variables to convert. All variables are already continuous.');
                return;
            }

            // Ask user for conversion method
            const method = confirm(
                `Convert ${categoricalColumns.length} categorical variable(s) to numerical?\n\n` +
                `Click OK for One-Hot Encoding (creates binary columns)\n` +
                `Click Cancel for Label Encoding (maps to integers)`
            ) ? 'onehot' : 'label';

            console.log(`Converting categorical variables using ${method} encoding...`);

            let conversionCount = 0;
            const newColumns = [];

            categoricalColumns.forEach(column => {
                // Get unique values
                const uniqueValues = new Set();
                allData.forEach(row => {
                    const value = row[column];
                    if (value !== null && value !== undefined && value !== '') {
                        uniqueValues.add(String(value));
                    }
                });

                if (method === 'onehot') {
                    // One-hot encoding: create binary columns for each category
                    const categories = Array.from(uniqueValues).sort();

                    categories.forEach(category => {
                        const newColumnName = `${column}_${category}`.replace(/[^a-zA-Z0-9_]/g, '_');
                        newColumns.push(newColumnName);

                        // Add new column to allColumns if not already there
                        if (!allColumns.includes(newColumnName)) {
                            allColumns.push(newColumnName);
                        }

                        // Set values
                        allData.forEach(row => {
                            const value = String(row[column] || '');
                            row[newColumnName] = (value === category) ? 1 : 0;
                        });
                    });

                    // Mark original column as converted (could hide it or mark it)
                    conversionCount += categories.length;
                } else {
                    // Label encoding: map categories to integers
                    const categories = Array.from(uniqueValues).sort();
                    const labelMap = {};
                    categories.forEach((cat, index) => {
                        labelMap[cat] = index;
                    });

                    // Update the column in place
                    allData.forEach(row => {
                        const value = String(row[column] || '');
                        row[column] = labelMap[value] !== undefined ? labelMap[value] : null;
                    });

                    // Update variable type to continuous
                    if (!variableChanges[column]) {
                        variableChanges[column] = {};
                    }
                    variableChanges[column].variable_type = 'continuous';
                    conversionCount++;
                }
            });

            // Save updated columns to localStorage
            localStorage.setItem('allColumns', JSON.stringify(allColumns));
            localStorage.setItem('variableChanges', JSON.stringify(variableChanges));
            localStorage.setItem('allData', JSON.stringify(allData));
            dataModified = true;

            alert(`Successfully converted ${conversionCount} categorical variable(s) using ${method === 'onehot' ? 'One-Hot Encoding' : 'Label Encoding'}.\n\n` +
                `${method === 'onehot' ? `Created ${newColumns.length} new binary columns.` : 'Updated columns to numerical values.'}`);

            // Refresh the interface
            initializeModelTrainingInterface();
            console.log('Categorical to numerical conversion complete');
        }

        function saveEmbeddings() {
            try {
                if (!allData || allData.length === 0) {
                    alert('No data available to save embeddings.');
                    return;
                }

                // Get selected features and label
                const label = document.getElementById('labelSelection')?.value || null;
                const selectedFeatures = Array.from(document.querySelectorAll('.feature-checkbox:checked'))
                    .map(cb => cb.value)
                    .filter(feature => feature && feature !== label);

                if (selectedFeatures.length === 0) {
                    alert('Please select at least one feature before saving embeddings.');
                    return;
                }

                // Extract embeddings (feature vectors) for each row
                const embeddings = allData.map((row, index) => {
                    const embedding = {
                        row_id: index,
                        features: {},
                        feature_vector: []
                    };

                    // Extract feature values
                    selectedFeatures.forEach(feature => {
                        const value = row[feature];
                        embedding.features[feature] = value;
                        // Add to feature vector (convert to number)
                        const numValue = parseFloat(value);
                        embedding.feature_vector.push(isNaN(numValue) ? 0 : numValue);
                    });

                    // Include label if available
                    if (label) {
                        embedding.label = row[label];
                    }

                    return embedding;
                });

                // Create embeddings export object
                const embeddingsExport = {
                    metadata: {
                        exported_at: new Date().toISOString(),
                        features: selectedFeatures,
                        label: label || null,
                        total_rows: embeddings.length,
                        feature_dimension: selectedFeatures.length,
                        embedding_format: 'feature_vector'
                    },
                    embeddings: embeddings,
                    feature_names: selectedFeatures
                };

                // Convert to JSON string
                const jsonString = JSON.stringify(embeddingsExport, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);

                // Create download link
                const a = document.createElement('a');
                a.href = url;
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
                a.download = `embeddings_${timestamp}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                alert(`Embeddings saved successfully!\n\nFeatures: ${selectedFeatures.length}\nRows: ${embeddings.length}\nDimension: ${selectedFeatures.length}`);
                console.log('Embeddings exported successfully', embeddingsExport);
            } catch (error) {
                console.error('Error saving embeddings:', error);
                alert('Error saving embeddings: ' + error.message);
            }
        }

        function saveProcessedDataset() {
            try {
                // Get selected features and label
                const label = document.getElementById('labelSelection')?.value || null;
                const selectedFeatures = Array.from(document.querySelectorAll('.feature-checkbox:checked'))
                    .map(cb => cb.value)
                    .filter(feature => feature && feature !== label); // Remove empty values and label

                if (selectedFeatures.length === 0) {
                    alert('Please select at least one feature to save.');
                    return;
                }

                if (!label) {
                    alert('Please select a label (target variable) before saving.');
                    return;
                }

                // Create processed dataset with only selected features and label
                const processedData = allData.map(row => {
                    const processedRow = {};
                    // Include all selected features (excluding label)
                    selectedFeatures.forEach(feature => {
                        processedRow[feature] = row[feature];
                    });
                    // Include label separately
                    processedRow[label] = row[label];
                    return processedRow;
                });

                // Create export object
                const datasetExport = {
                    metadata: {
                        exported_at: new Date().toISOString(),
                        features: selectedFeatures,
                        label: label,
                        total_rows: processedData.length,
                        total_features: selectedFeatures.length
                    },
                    data: processedData,
                    features: selectedFeatures,
                    label: label
                };

                // Convert to JSON string
                const jsonString = JSON.stringify(datasetExport, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);

                // Create download link
                const a = document.createElement('a');
                a.href = url;
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
                a.download = `training_dataset_${timestamp}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                alert(`Dataset saved successfully!\n\nFeatures: ${selectedFeatures.length}\nLabel: ${label}\nRows: ${processedData.length}`);
                console.log('Processed dataset exported successfully');
            } catch (error) {
                console.error('Error saving processed dataset:', error);
                alert('Error saving dataset: ' + error.message);
            }
        }

        function previewTrainingDataset() {
            const viewer = document.getElementById('trainingDatasetViewer');

            if (!viewer) {
                alert('Dataset viewer not found');
                return;
            }

            // Get selected features and label
            const label = document.getElementById('labelSelection')?.value || null;
            const selectedFeatures = Array.from(document.querySelectorAll('.feature-checkbox:checked'))
                .map(cb => cb.value)
                .filter(feature => feature && feature !== label); // Exclude label from features

            if (selectedFeatures.length === 0) {
                viewer.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #EF4444;">
                        <h4>No Features Selected</h4>
                        <p>Please select at least one feature to preview.</p>
                    </div>
                `;
                return;
            }

            if (!label) {
                viewer.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #F59E0B;">
                        <h4>No Label Selected</h4>
                        <p>Please select a label (target variable) to preview the training dataset.</p>
                    </div>
                `;
                return;
            }

            // Create preview with selected features and label (label shown last)
            const displayColumns = [...selectedFeatures, label];
            const previewData = allData.slice(0, Math.min(100, allData.length)); // Show first 100 rows

            // Create table
            let tableHTML = `
                <div style="margin-bottom: 15px; padding: 12px; background: #F0F9FF; border-radius: 8px; border: 1px solid #BAE6FD;">
                    <div style="display: flex; gap: 20px; flex-wrap: wrap; font-size: 0.9rem;">
                        <div><strong>Selected Features:</strong> ${selectedFeatures.length}</div>
                        <div><strong>Label:</strong> ${label}</div>
                        <div><strong>Total Rows:</strong> ${allData.length.toLocaleString()}</div>
                        <div><strong>Preview Rows:</strong> ${previewData.length}</div>
                    </div>
                </div>
                <div style="overflow-x: auto;">
                    <table style="width: 100%; border-collapse: collapse; font-size: 0.875rem;">
                        <thead>
                            <tr style="background: #F9FAFB; border-bottom: 2px solid #E5E7EB;">
                                ${displayColumns.map(col => `
                                    <th style="padding: 12px; text-align: left; font-weight: 600; color: #374151; position: sticky; top: 0; background: #F9FAFB; ${col === label ? 'background: #FEF3C7;' : ''}">
                                        ${col === label ? '[LABEL] ' : ''}${col}
                                    </th>
                                `).join('')}
                            </tr>
                        </thead>
                        <tbody>
            `;

            previewData.forEach((row, rowIndex) => {
                tableHTML += '<tr style="border-bottom: 1px solid #E5E7EB;">';
                displayColumns.forEach(col => {
                    const value = row[col];
                    const displayValue = value === null || value === undefined || value === '' ?
                        '<span style="color: #9CA3AF; font-style: italic;">null</span>' :
                        String(value);
                    tableHTML += `<td style="padding: 10px 12px; color: #1F2937;">${displayValue}</td>`;
                });
                tableHTML += '</tr>';
            });

            tableHTML += `
                        </tbody>
                    </table>
                </div>
            `;

            viewer.innerHTML = tableHTML;
        }

        function proceedToActualTraining() {
            alert('Model training interface will be implemented next!');
            // TODO: Implement actual model training
        }
        */ // End of commented model training functions


        function updateVariableStats() {
            if (!variableData) return;

            // Calculate statistics based on actual checkbox states
            let selectedCount = 0;
            let selectedTotal = 0;
            let deselectedCount = 0;
            let deselectedTotal = 0;
            let missingCount = 0;

            // Go through all value rows and check actual checkbox states
            for (let i = 0; i < variableData.value_counts.length; i++) {
                const checkbox = document.getElementById(`select-${i}`);
                const item = variableData.value_counts[i];

                if (checkbox && checkbox.checked) {
                    selectedCount++;
                    selectedTotal += item.count;

                    // Count NaN values
                    if (item.value === 'Missing/NaN' ||
                        item.value.toLowerCase().includes('missing') ||
                        item.value.toLowerCase().includes('nan')) {
                        missingCount += item.count;
                    }
                } else {
                    deselectedCount++;
                    deselectedTotal += item.count;
                }
            }

            // Update the display
            const totalValuesEl = document.getElementById('totalValues');
            const uniqueValuesEl = document.getElementById('uniqueValues');
            const missingValuesEl = document.getElementById('missingValues');

            // Show original totals (not affected by selections)
            const originalTotal = variableData.value_counts.reduce((sum, item) => sum + item.count, 0);
            const originalUnique = variableData.value_counts.length;

            if (totalValuesEl) totalValuesEl.textContent = originalTotal.toLocaleString();
            if (uniqueValuesEl) uniqueValuesEl.textContent = originalUnique;

            if (missingValuesEl) missingValuesEl.textContent = missingCount;

            // Update the variableData object with new stats
            variableData.total_values = selectedTotal;
            variableData.unique_values = selectedCount;
            variableData.missing_count = missingCount;

        }

        function saveVariableChanges() {
            // Save changes for current variable
            const currentColumn = allColumns[currentVariableIndex];

            // Save to memory first
            saveVariableChangesToMemory();

            // Collect all selected values and their new names
            const selectedValues = [];
            const excludedValues = [];

            for (let i = 0; i < variableData.value_counts.length; i++) {
                const checkbox = document.getElementById(`select-${i}`);
                const item = variableData.value_counts[i];

                if (checkbox && checkbox.checked) {
                    selectedValues.push({
                        original: item.original_value,
                        new: item.isNaN ? null : item.value, // Set to null if marked as NaN
                        count: item.count,
                        isNaN: item.isNaN || false
                    });
                } else {
                    excludedValues.push({
                        original: item.original_value,
                        new: item.value,
                        count: item.count
                    });
                }
            }

            // Apply renamed values to the actual dataset FIRST (before setting to null)
            applyRenamedValuesToDataset(currentColumn);

            // Remove excluded values (deselected) from the dataset
            removeExcludedValuesFromDataset(currentColumn, excludedValues);

            // Apply NaN values to the actual dataset LAST (after renaming, as it sets to null)
            applyNaNValuesToDataset(currentColumn);

            // Verify changes were applied to allData
            console.log('========== VERIFICATION: Changes applied to allData ==========');
            console.log(`Column: ${currentColumn}`);
            console.log(`Total rows in allData: ${allData.length}`);
            console.log(`Sample of first 5 values in allData for this column:`);
            for (let i = 0; i < Math.min(5, allData.length); i++) {
                console.log(`  Row ${i}: ${allData[i][currentColumn]}`);
            }
            console.log('===============================================================');

            // Show summary of changes
            const summary = `
Changes saved for variable: ${currentColumn}

Selected values: ${selectedValues.length}
Excluded values: ${excludedValues.length}
Total values: ${variableData.value_counts.length}

Selected values will be kept in the dataset.
Excluded values will be removed from the dataset.
            `;

            // Silently complete the operation - no popup unless there's an error

            // Update the sidebar to show this variable is processed
            updateVariableStatus(currentVariableIndex, 'completed');

            // Preserve variable_type before clearing cache
            let preservedVariableType = null;
            if (currentColumn && variableChanges[currentColumn] && variableChanges[currentColumn].variable_type) {
                preservedVariableType = variableChanges[currentColumn].variable_type;
                console.log(`Preserving variable_type "${preservedVariableType}" before clearing cache`);

                // Keep only the variable_type in the cache, clear the rest so it recalculates
                variableChanges[currentColumn] = {
                    variable_type: preservedVariableType
                };
            } else {
                // No variable_type to preserve, delete entirely
                delete variableChanges[currentColumn];
            }

            localStorage.setItem('variableChanges', JSON.stringify(variableChanges));
            console.log('Cleared cached variable data (preserved variable_type) to force recalculation from updated allData');

            // Refresh the current variable display immediately with updated values
            loadCurrentVariable();

            // Refresh the data viewer to show updated values
            refreshDataViewerIfVisible();
        }

        function updateVariableStatus(index, status) {
            const element = document.getElementById(`variable-${index}`);
            if (element) {
                if (status === 'completed') {
                    element.style.borderColor = '#10B981';
                    element.style.background = '#F0FDF4';

                    // Add a checkmark indicator
                    const statusSpan = element.querySelector('.status-indicator');
                    if (!statusSpan) {
                        const statusDiv = document.createElement('div');
                        statusDiv.className = 'status-indicator';
                        statusDiv.style.cssText = 'margin-top: 8px; font-size: 0.7rem; color: #10B981; font-weight: 600;';
                        statusDiv.innerHTML = 'Completed';
                        element.appendChild(statusDiv);
                    }
                }
            }
        }

        function applyNaNValuesToDataset(column) {
            console.log(`Applying NaN values to dataset for column: ${column}`);
            console.log(`variableData.value_counts length: ${variableData.value_counts.length}`);

            if (!allData || allData.length === 0) {
                console.error('No data available to apply NaN values');
                return;
            }

            let updatedCount = 0;
            let nanItems = [];

            // Loop through each value in value_counts
            for (let i = 0; i < variableData.value_counts.length; i++) {
                const item = variableData.value_counts[i];
                console.log(`Item ${i}: value="${item.value}", original_value="${item.original_value}", isNaN=${item.isNaN}`);

                // If this value is marked as NaN, update it in the dataset
                if (item.isNaN) {
                    nanItems.push(item);
                    // Use original_value to match against dataset, not the potentially edited value
                    const valueToMatch = item.original_value || item.value;
                    console.log(`Setting "${valueToMatch}" to null in column "${column}"`);

                    // Update all rows where this value appears
                    allData.forEach(row => {
                        if (String(row[column]) === String(valueToMatch)) {
                            row[column] = null;
                            updatedCount++;
                        }
                    });
                }
            }

            console.log(`Found ${nanItems.length} NaN items, updated ${updatedCount} rows with NaN values for column ${column}`);

            // Mark data as modified and save to localStorage
            dataModified = true;
            try {
                localStorage.setItem('dataModified', 'true');
                console.log('Saved dataModified to localStorage');
                // Don't save allData to localStorage if it's too large
                const dataSize = JSON.stringify(allData).length;
                if (dataSize > 5 * 1024 * 1024) { // 5MB limit
                    console.warn('allData is too large (' + (dataSize / 1024 / 1024).toFixed(2) + 'MB), skipping localStorage save');
                } else {
                    localStorage.setItem('allData', JSON.stringify(allData));
                    console.log('Saved allData to localStorage');
                }
            } catch (error) {
                console.error('Error saving to localStorage:', error);
            }
        }

        function applyRenamedValuesToDataset(column) {
            console.log(`Applying renamed values to dataset for column: ${column}`);

            if (!allData || allData.length === 0) {
                console.error('No data available to apply renamed values');
                return;
            }

            let updatedCount = 0;

            // Loop through each value in value_counts
            for (let i = 0; i < variableData.value_counts.length; i++) {
                const item = variableData.value_counts[i];
                const checkbox = document.getElementById(`select-${i}`);

                // Only apply if checked and not marked as NaN
                if (checkbox && checkbox.checked && !item.isNaN) {
                    const originalValue = item.original_value || item.value;
                    const newValue = item.value;

                    // Only update if the value has changed
                    if (String(originalValue) !== String(newValue)) {
                        console.log(`Renaming "${originalValue}" to "${newValue}" in column "${column}"`);

                        // Update all rows where this value appears
                        allData.forEach(row => {
                            if (String(row[column]) === String(originalValue)) {
                                row[column] = newValue;
                                updatedCount++;
                            }
                        });
                    }
                }
            }

            console.log(`Updated ${updatedCount} rows with renamed values for column ${column}`);

            // Mark data as modified and save to localStorage
            dataModified = true;
            try {
                localStorage.setItem('dataModified', 'true');
                console.log('Saved dataModified to localStorage');
                // Don't save allData to localStorage if it's too large
                const dataSize = JSON.stringify(allData).length;
                if (dataSize > 5 * 1024 * 1024) { // 5MB limit
                    console.warn('allData is too large (' + (dataSize / 1024 / 1024).toFixed(2) + 'MB), skipping localStorage save');
                } else {
                    localStorage.setItem('allData', JSON.stringify(allData));
                    console.log('Saved allData to localStorage');
                }
            } catch (error) {
                console.error('Error saving to localStorage:', error);
            }
        }

        function removeExcludedValuesFromDataset(column, excludedValues) {
            console.log(`Removing excluded values from dataset for column: ${column}`);

            if (!allData || allData.length === 0) {
                console.error('No data available to remove excluded values');
                return;
            }

            if (!excludedValues || excludedValues.length === 0) {
                console.log('No excluded values to remove');
                return;
            }

            let removedCount = 0;

            // Remove all excluded values by setting them to null
            excludedValues.forEach(excludedItem => {
                const originalValue = excludedItem.original || excludedItem.original_value;
                console.log(`Removing "${originalValue}" from column "${column}"`);

                allData.forEach(row => {
                    if (String(row[column]) === String(originalValue)) {
                        row[column] = null;
                        removedCount++;
                    }
                });
            });

            console.log(`Removed ${removedCount} rows with excluded values for column ${column}`);

            // Mark data as modified and save to localStorage
            dataModified = true;
            try {
                localStorage.setItem('dataModified', 'true');
                console.log('Saved dataModified to localStorage');
                // Don't save allData to localStorage if it's too large
                const dataSize = JSON.stringify(allData).length;
                if (dataSize > 5 * 1024 * 1024) { // 5MB limit
                    console.warn('allData is too large (' + (dataSize / 1024 / 1024).toFixed(2) + 'MB), skipping localStorage save');
                } else {
                    localStorage.setItem('allData', JSON.stringify(allData));
                    console.log('Saved allData to localStorage');
                }
            } catch (error) {
                console.error('Error saving to localStorage:', error);
            }
        }


        // Find and Replace Functions
        function performFindReplace() {
            const findText = document.getElementById('findText').value.trim();
            const replaceText = document.getElementById('replaceText').value;
            const previewMode = document.getElementById('previewMode').checked;

            if (!findText) {
                alert('Please enter text to find');
                return;
            }

            if (previewMode) {
                previewFindReplace();
            } else {
                applyFindReplaceChanges();
            }
        }

        function previewFindReplace() {
            const findText = document.getElementById('findText').value.trim();
            const replaceText = document.getElementById('replaceText').value;
            const caseSensitive = document.getElementById('caseSensitive').checked;
            const wholeWord = document.getElementById('wholeWord').checked;

            if (!findText) {
                alert('Please enter text to find');
                return;
            }

            const matches = [];
            const regex = buildFindRegex(findText, caseSensitive, wholeWord);

            // Find all matches
            for (let i = 0; i < variableData.value_counts.length; i++) {
                const item = variableData.value_counts[i];
                const originalValue = item.value;

                if (regex.test(originalValue)) {
                    const newValue = originalValue.replace(regex, replaceText);
                    if (originalValue !== newValue) {
                        matches.push({
                            index: i,
                            original: originalValue,
                            new: newValue,
                            count: item.count
                        });
                    }
                }
            }

            if (matches.length === 0) {
                alert(`No matches found for "${findText}"`);
                return;
            }

            // Show preview
            const previewDiv = document.getElementById('findReplacePreview');
            const resultsDiv = document.getElementById('previewResults');

            resultsDiv.innerHTML = `
                <div style="margin-bottom: 10px; color: #92400E; font-weight: 600;">
                    Found ${matches.length} values that will be changed:
                </div>
                <div style="max-height: 200px; overflow-y: auto; border: 1px solid #F1F5F9; border-radius: 6px;">
                    ${matches.map(match => `
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; border-bottom: 1px solid #F1F5F9;">
                            <div style="flex: 1;">
                                <span style="color: #1E40AF; font-weight: 500;">${match.original}</span>
                                <span style="color: #64748B; margin: 0 8px;">/</span>
                                <span style="color: #10B981; font-weight: 500;">${match.new}</span>
                            </div>
                            <div style="background: #87CEEB; color: white; padding: 2px 8px; border-radius: 12px; font-size: 0.8rem; font-weight: 600;">
                                ${match.count}
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;

            previewDiv.style.display = 'block';
        }

        function buildFindRegex(findText, caseSensitive, wholeWord) {
            // Escape special regex characters
            const escapedText = findText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

            // Build regex pattern
            let pattern = escapedText;
            if (wholeWord) {
                pattern = `\\b${escapedText}\\b`;
            }

            const flags = caseSensitive ? 'g' : 'gi';
            return new RegExp(pattern, flags);
        }

        function applyFindReplace() {
            applyFindReplaceChanges();
            cancelFindReplace();
        }

        function applyFindReplaceChanges() {
            const findText = document.getElementById('findText').value.trim();
            const replaceText = document.getElementById('replaceText').value;
            const caseSensitive = document.getElementById('caseSensitive').checked;
            const wholeWord = document.getElementById('wholeWord').checked;

            if (!findText) {
                alert('Please enter text to find');
                return;
            }

            const regex = buildFindRegex(findText, caseSensitive, wholeWord);
            let updatedCount = 0;

            // Apply changes
            for (let i = 0; i < variableData.value_counts.length; i++) {
                const item = variableData.value_counts[i];
                const originalValue = item.value;

                if (regex.test(originalValue)) {
                    const newValue = originalValue.replace(regex, replaceText);
                    if (originalValue !== newValue) {
                        item.value = newValue;

                        // Update the input field
                        const input = document.getElementById(`name-${i}`);
                        if (input) {
                            input.value = newValue;
                        }
                        updatedCount++;
                    }
                }
            }

            // Save changes to memory
            saveVariableChangesToMemory();

            // Silently complete the operation - no popup unless there's an error
        }

        function cancelFindReplace() {
            document.getElementById('findReplacePreview').style.display = 'none';
        }

        function clearFindReplace() {
            document.getElementById('findText').value = '';
            document.getElementById('replaceText').value = '';
            document.getElementById('caseSensitive').checked = false;
            document.getElementById('wholeWord').checked = false;
            document.getElementById('previewMode').checked = true;
            cancelFindReplace();
        }

        function toggleFindReplace() {
            const content = document.getElementById('findReplaceContent');
            const toggle = document.getElementById('findReplaceToggle');

            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = '‚àí';
            } else {
                content.style.display = 'none';
                toggle.textContent = '+';
            }
        }

        function goBackToViewer() {
            // Show upload section and data viewer, hide cleaning page
            const cleaningPage = document.getElementById('cleaningPage');
            const featureEngineeringPage = document.getElementById('featureEngineeringPage');
            const uploadSection = document.getElementById('uploadSection');
            const modelSelection = document.getElementById('modelSelection');
            const dataViewer = document.getElementById('dataViewer');
            const result = document.getElementById('result');
            const newUploadBtn = document.getElementById('newUploadBtn');

            if (cleaningPage) {
                cleaningPage.style.display = 'none';
                cleaningPage.style.visibility = 'hidden';
            }
            if (featureEngineeringPage) {
                featureEngineeringPage.style.display = 'none';
                featureEngineeringPage.style.visibility = 'hidden';
            }
            if (uploadSection) {
                uploadSection.style.display = 'block';
                uploadSection.style.visibility = 'visible';
            }
            if (modelSelection) {
                modelSelection.style.display = 'block';
                modelSelection.style.visibility = 'visible';
            }
            if (dataViewer) {
                dataViewer.style.display = 'block';
                dataViewer.style.visibility = 'visible';
            }
            if (result) {
                result.style.display = 'block';
                result.style.visibility = 'visible';
            }
            if (newUploadBtn) {
                newUploadBtn.style.display = 'block';
                newUploadBtn.style.visibility = 'visible';
            }

            // Make sure data is still displayed if we have uploaded data
            if (uploadedData && uploadedData.file_ids && uploadedData.file_ids.length > 0) {
                showDataViewer(uploadedData);
            }
        }

        function previewCleaning() {
            // Show a preview of what will be cleaned
            alert('Preview feature coming soon! This will show you exactly what changes will be made to your dataset before applying them.');
        }

        function startCleaning() {
            // Start the actual cleaning process
            const cleaningContent = document.getElementById('cleaningContent');
        * / / / End of commented data cleaning functions - now in frontend / js / dataCleaning.js

            function startCleaning() {
                // Start the actual cleaning process
                const cleaningContent = document.getElementById('cleaningContent');

                cleaningContent.innerHTML = `
                <div style="text-align: center; padding: 40px;">
                    <div style="font-size: 3rem; margin-bottom: 20px;">üßπ</div>
                    <h4 style="color: #1E40AF; margin-bottom: 15px; font-size: 1.5rem;">Cleaning Your Dataset</h4>
                    <p style="color: #64748B; margin-bottom: 30px;">
                        This feature is coming soon! We're building the complete EHR data cleaning pipeline based on your previous features.
                    </p>
                    <div style="background: linear-gradient(135deg, #F8FEFF 0%, #E8F8FF 100%); border: 1px solid #B8E6FF; border-radius: 12px; padding: 20px; margin: 20px 0;">
                        <h5 style="color: #1E40AF; margin-bottom: 10px;">üîß Planned Features:</h5>
                        <ul style="text-align: left; color: #64748B; margin: 0; padding-left: 20px;">
                            <li>Variable-by-variable cleaning interface</li>
                            <li>Find & replace functionality</li>
                            <li>Category mapping and combination</li>
                            <li>Data type conversion</li>
                            <li>Missing value handling</li>
                            <li>Outlier detection and removal</li>
                            <li>Undo/redo functionality</li>
                            <li>Real-time preview of changes</li>
                        </ul>
                    </div>
                    <button onclick="goBackToViewer()" style="background: linear-gradient(135deg, #3B82F6 0%, #87CEEB 100%); color: white; border: none; padding: 12px 24px; border-radius: 12px; font-weight: 600; cursor: pointer; margin-top: 20px;">
                        Back to Data View
                    </button>
                </div>
            `;
            }

        // Visualization functions moved to frontend/js/visualization.js
        /* Visualization functions now in module:
        function showVisualizationInterface() {
            // Hide all other elements and show only visualization page
            const uploadSection = document.getElementById('uploadSection');
            const modelSelection = document.getElementById('modelSelection');
            const dataViewer = document.getElementById('dataViewer');
            const cleaningPage = document.getElementById('cleaningPage');
            const featureEngineeringPage = document.getElementById('featureEngineeringPage');
            const visualizationPage = document.getElementById('visualizationPage');
            const result = document.getElementById('result');
            const newUploadBtn = document.getElementById('newUploadBtn');

            // Hide all sections except visualization
            if (uploadSection) {
                uploadSection.style.display = 'none';
                uploadSection.style.visibility = 'hidden';
            }
            if (modelSelection) {
                modelSelection.style.display = 'none';
                modelSelection.style.visibility = 'hidden';
            }
            if (dataViewer) {
                dataViewer.style.display = 'none';
                dataViewer.style.visibility = 'hidden';
            }
            if (cleaningPage) {
                cleaningPage.style.display = 'none';
                cleaningPage.style.visibility = 'hidden';
            }
            if (featureEngineeringPage) {
                featureEngineeringPage.style.display = 'none';
                featureEngineeringPage.style.visibility = 'hidden';
            }
            if (result) {
                result.style.display = 'none';
                result.style.visibility = 'hidden';
            }
            if (newUploadBtn) {
                newUploadBtn.style.display = 'none';
                newUploadBtn.style.visibility = 'hidden';
            }
            if (visualizationPage) {
                visualizationPage.style.display = 'block';
                visualizationPage.style.visibility = 'visible';
            }

            // Initialize visualization interface
            initializeVisualizationInterface();
        }

        function initializeVisualizationInterface() {
            const visualizationContent = document.getElementById('visualizationContent');

            if (!allData || allData.length === 0 || !allColumns || allColumns.length === 0) {
                visualizationContent.innerHTML = `
                    <div style="text-align: center; padding: 60px 20px; color: #64748B;">
                        <div style="font-size: 3rem; margin-bottom: 20px;"></div>
                        <h4 style="color: #1E40AF; margin-bottom: 15px;">No Data Available</h4>
                        <p style="font-size: 1rem; margin-bottom: 30px;">Please upload a dataset first to visualize.</p>
                        <button onclick="goBackToViewer()" style="background: #6B7280; color: white; border: none; padding: 12px 24px; border-radius: 8px; font-weight: 600; cursor: pointer;">
                            Back to Data Viewer
                        </button>
                    </div>
                `;
                return;
            }

            // Create visualization interface with all columns
            const visualizationHTML = `
                <div style="padding: 20px;">
                    <div style="margin-bottom: 30px;">
                        <h2 style="color: #1E40AF; margin-bottom: 10px; font-weight: 700;">Data Visualizations</h2>
                        <p style="color: #64748B; font-size: 0.95rem;">Select a variable to visualize its distribution</p>
                    </div>

                    <!-- Variable Selection -->
                    <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px; margin-bottom: 30px;">
                        ${allColumns.map(column => {
                const varType = variableChanges[column]?.variable_type || 'categorical';
                const isContinuous = varType === 'continuous';
                return `
                                <button onclick="visualizeColumn('${column}')" 
                                        style="background: ${isContinuous ? 'linear-gradient(135deg, #10B981 0%, #059669 100%)' : 'linear-gradient(135deg, #3B82F6 0%, #1D4ED8 100%)'}; 
                                                color: white; border: none; padding: 15px; border-radius: 10px; 
                                                font-weight: 600; cursor: pointer; text-align: left; transition: all 0.2s;"
                                        onmouseover="this.style.transform='scale(1.02)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.15)'"
                                        onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'">
                                    <div style="font-size: 0.9rem; margin-bottom: 5px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                                        ${column}
                                    </div>
                                    <div style="font-size: 0.75rem; opacity: 0.9;">
                                        ${isContinuous ? 'Histogram' : 'Bar Chart'}
                                    </div>
                                </button>
                            `;
            }).join('')}
                    </div>

                    <!-- Chart Container -->
                    <div id="chartContainer" style="background: white; border: 1px solid #E5E7EB; border-radius: 12px; padding: 30px; margin-bottom: 20px; min-height: 400px;">
                        <div style="text-align: center; padding: 60px 20px; color: #9CA3AF;">
                            <div style="font-size: 3rem; margin-bottom: 15px;"></div>
                            <p style="font-size: 1.1rem;">Select a variable from above to visualize</p>
                        </div>
                    </div>

                    <!-- Navigation Buttons -->
                    <div style="position: fixed; bottom: 20px; left: 20px; right: 20px; display: flex; justify-content: space-between; gap: 15px; z-index: 1000;">
                        <div>
                            <button onclick="showFeatureEngineeringInterface()" style="background: #6B7280; color: white; border: none; padding: 12px 24px; border-radius: 8px; font-weight: 600; cursor: pointer;">
                                Back to Feature Engineering
                            </button>
                        </div>
                        <div>
                            <button onclick="proceedToModelTraining()" style="background: linear-gradient(135deg, #059669 0%, #047857 100%); color: white; border: none; padding: 12px 24px; border-radius: 8px; font-weight: 600; cursor: pointer;">
                                Model Training
                            </button>
                        </div>
                    </div>
                </div>
            `;

            visualizationContent.innerHTML = visualizationHTML;
        }

        function visualizeColumn(column) {
            const chartContainer = document.getElementById('chartContainer');

            if (!allData || allData.length === 0) {
                alert('No data available for visualization');
                return;
            }

            // Determine if variable is categorical or continuous
            const varType = variableChanges[column]?.variable_type || 'categorical';
            const isContinuous = varType === 'continuous';

            // Calculate statistics
            const values = [];
            let nanCount = 0;

            allData.forEach(row => {
                const value = row[column];
                if (value === null || value === undefined || value === '' || value === 'nan' || value === 'NaN') {
                    nanCount++;
                } else {
                    values.push(value);
                }
            });

            // Destroy existing chart if it exists
            if (window.currentChart) {
                window.currentChart.destroy();
            }

            // Create chart based on type
            if (isContinuous) {
                createHistogram(column, values, nanCount);
            } else {
                createBarChart(column, values, nanCount);
            }
        }

        function createBarChart(column, values, nanCount) {
            const chartContainer = document.getElementById('chartContainer');

            // Count frequencies
            const valueCounts = {};
            values.forEach(val => {
                const key = String(val);
                valueCounts[key] = (valueCounts[key] || 0) + 1;
            });

            // Sort by count descending
            const sortedEntries = Object.entries(valueCounts).sort((a, b) => b[1] - a[1]);
            const labels = sortedEntries.map(([label]) => label);
            const data = sortedEntries.map(([, count]) => count);

            // Limit to top 20 categories if too many
            const maxCategories = 20;
            const displayLabels = labels.slice(0, maxCategories);
            const displayData = data.slice(0, maxCategories);

            chartContainer.innerHTML = `
                <div style="margin-bottom: 20px;">
                    <h3 style="color: #1E40AF; margin-bottom: 10px; font-weight: 700;">${column}</h3>
                    <p style="color: #64748B; margin-bottom: 15px;">
                        <strong>Total Values:</strong> ${values.length + nanCount} | 
                        <strong>Valid Values:</strong> ${values.length} | 
                        <strong>NaN/Missing:</strong> ${nanCount} (${((nanCount / (values.length + nanCount)) * 100).toFixed(1)}%)
                    </p>
                </div>
                <div style="position: relative; height: 500px;">
                    <canvas id="barChart"></canvas>
                </div>
            `;

            const ctx = document.getElementById('barChart').getContext('2d');
            window.currentChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: displayLabels,
                    datasets: [{
                        label: 'Count',
                        data: displayData,
                        backgroundColor: 'rgba(59, 130, 246, 0.8)',
                        borderColor: 'rgba(59, 130, 246, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    return `Count: ${context.parsed.y}`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                precision: 0
                            }
                        },
                        x: {
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45
                            }
                        }
                    },
                    plugins: {
                        datalabels: false
                    }
                },
                plugins: [{
                    id: 'datalabels',
                    afterDraw: (chart) => {
                        const ctx = chart.ctx;
                        ctx.font = 'bold 12px Arial';
                        ctx.fillStyle = '#1E40AF';
                        ctx.textAlign = 'center';
                        chart.data.datasets.forEach((dataset, i) => {
                            const meta = chart.getDatasetMeta(i);
                            meta.data.forEach((bar, index) => {
                                const value = dataset.data[index];
                                ctx.fillText(value, bar.x, bar.y - 5);
                            });
                        });
                    }
                }]
            });
        }

        function createHistogram(column, values, nanCount) {
            const chartContainer = document.getElementById('chartContainer');

            // Convert to numbers and filter out NaN
            const numericValues = values.map(v => parseFloat(v)).filter(v => !isNaN(v) && isFinite(v));

            if (numericValues.length === 0) {
                chartContainer.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #EF4444;">
                        <h4>No valid numeric values to display</h4>
                        <p>All values are missing or non-numeric.</p>
                    </div>
                `;
                return;
            }

            // Calculate histogram bins
            const min = Math.min(...numericValues);
            const max = Math.max(...numericValues);
            const binCount = Math.min(20, Math.ceil(Math.sqrt(numericValues.length)));
            const binWidth = (max - min) / binCount;

            const bins = Array(binCount).fill(0);
            const binLabels = [];

            for (let i = 0; i < binCount; i++) {
                const binStart = min + i * binWidth;
                const binEnd = min + (i + 1) * binWidth;
                binLabels.push(`${binStart.toFixed(2)}-${binEnd.toFixed(2)}`);
            }

            // Count values in each bin
            numericValues.forEach(val => {
                let binIndex = Math.floor((val - min) / binWidth);
                if (binIndex === binCount) binIndex = binCount - 1; // Handle edge case
                bins[binIndex]++;
            });

            chartContainer.innerHTML = `
                <div style="margin-bottom: 20px;">
                    <h3 style="color: #1E40AF; margin-bottom: 10px; font-weight: 700;">${column}</h3>
                    <p style="color: #64748B; margin-bottom: 15px;">
                        <strong>Total Values:</strong> ${values.length + nanCount} | 
                        <strong>Valid Values:</strong> ${numericValues.length} | 
                        <strong>NaN/Missing:</strong> ${nanCount} (${((nanCount / (values.length + nanCount)) * 100).toFixed(1)}%) | 
                        <strong>Min:</strong> ${min.toFixed(2)} | 
                        <strong>Max:</strong> ${max.toFixed(2)} | 
                        <strong>Mean:</strong> ${(numericValues.reduce((a, b) => a + b, 0) / numericValues.length).toFixed(2)}
                    </p>
                </div>
                <div style="position: relative; height: 500px;">
                    <canvas id="histogramChart"></canvas>
                </div>
            `;

            const ctx = document.getElementById('histogramChart').getContext('2d');
            window.currentChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: binLabels,
                    datasets: [{
                        label: 'Frequency',
                        data: bins,
                        backgroundColor: 'rgba(16, 185, 129, 0.8)',
                        borderColor: 'rgba(16, 185, 129, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    return `Frequency: ${context.parsed.y}`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                precision: 0
                            }
                        },
                        x: {
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45
                            }
                        }
                    }
                },
                plugins: [{
                    id: 'datalabels',
                    afterDraw: (chart) => {
                        const ctx = chart.ctx;
                        ctx.font = 'bold 12px Arial';
                        ctx.fillStyle = '#059669';
                        ctx.textAlign = 'center';
                        chart.data.datasets.forEach((dataset, i) => {
                            const meta = chart.getDatasetMeta(i);
                            meta.data.forEach((bar, index) => {
                                const value = dataset.data[index];
                                if (value > 0) {
                                    ctx.fillText(value, bar.x, bar.y - 5);
                                }
                            });
                        });
                    }
                }]
            });
        }
        */ // End of commented visualization functions - now in frontend/js/visualization.js
    </script>

    <!-- Modular JavaScript Files -->
    <!-- Load order matters: config first, then utils, data manager, then feature modules -->
    <script src="/js/config.js"></script>
    <script src="/js/utils.js"></script>
    <script src="/js/dataManager.js"></script>
    <script src="/js/upload.js?v=3.0"></script>
    <script src="/js/dataViewer.js?v=2.6"></script>
    <script src="/js/dataCleaning.js?v=2.7"></script>
    <script src="/js/featureEngineering.js?v=2.5"></script>
    <script src="/js/visualization.js"></script>
    <script src="/js/modelTraining.js?v=3.2"></script>

</body>

</html>